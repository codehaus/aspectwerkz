<?xml version="1.0"?>
<document>
    <properties>
        <author email="jboner at codehaus dot org">jonas bon&#233;r</author>
        <author email="alex at gnilux dot com">alexandre vasseur</author>
        <title>Implementation issues</title>
    </properties>
    <body>
        <section name="Table of Contents">
            <p>
                <b>Implementation issues</b>
            </p>
            <p>
                This section documents the programming model for Aspects, Advices and Introductions (Mixins)
                in AspectWerkz.
            </p>
            <p>
                <ol>
                    <li>
                        <a href="#Aspects">Aspect models</a>
                    </li>
                    <li>
                        <a href="#Advice">Advice</a>
                    </li>
                    <li>
                        <a href="#JoinPoint instance">JoinPoint instance</a>
                    </li>
                    <li>
                        <a href="#Signature interfaces">Signature interfaces</a>
                    </li>
                    <li>
                        <a href="#RTTI interfaces">RTTI interfaces</a>
                    </li>
                    <li>
                        <a href="#Using the AspectContext class">Using the AspectContext class</a>
                    </li>
                    <li>
                        <a href="#Introductions">Introductions</a>
                    </li>
                    <li>
                        <a href="#Example of an Aspect">Example of an Aspect</a>
                    </li>
                    <li>
                        <a href="#Choosing a definition model">Choosing a definition model</a>
                    </li>
                </ol>
            </p>
        </section>
        <section name="Aspects">
            <p>
                In
                <code>AspectWerkz</code> any Java class can be an aspect (or more conceptually correct, can
                be defined to be
                <i>cross-cutting</i>), which means that it will become a unit of modularity
                for crosscutting concerns.
            </p>
            <p>
                They do not have to extend any special class or implement a specific interface, but can extend any
                class they want.
            </p>
            <p>
                The only requirement is that the aspect needs to have either
                <b>no</b> constructor at all
                (meaning implicitly a default one)
                <b>or</b> one of these two different constructors defined:
                <ul>
                    <li>
                        a default no-argument constructor - only needed if the aspect has a other constructors that
                        takes parameters (apart from the one below if defined)
                    </li>
                    <br/>
                    <li>
                        a constructor that takes a
                        <code>org.codehaus.aspectwerkz.AspectContext</code> instance
                        as its only parameter - this is needed if you want to retrieve information about the runtime
                        system, access paramaters defined at deployment time, access meta-data etc.
                        See
                        <a href="#Using the AspectContext class">Using the AspectContext class</a> section
                        for details.
                    </li>
                    <br/>
                </ul>
                If a constructor of type 2 is found then it is used else the default constructor. If no default
                constructor can be found then an exception is thrown.
            </p>
            <p>
                The aspect can then be defined using XML or annotations, see the
                <a href="xml_definition.html">XML definition</a> section or the
                <a href="attribute_definition.html">Annotation definition</a> section for more information.
            </p>
            <subsection name="Abstract aspects - aspect inheritance">
                <p>
                    Since the Aspects are pure Java classes, you have the possibility of
                    defining abstract aspects that you can reuse by implementing another aspect
                    that inherits the abstract aspect.
                </p>
                <p>
                    Aspect inheritance is exactly regular class inheritance. An abstract aspect
                    is defined using the
                    <code>abstract</code> keyword as a regular abstract class and is inherited
                    using the
                    <code>extends</code> keyword.
                </p>
                <p>
                    Nevertheless specific rules must be observed for advices represented as methods. Indeed, the advice
                    is likely to be invoked from the class it is applied to as a result of the weaving process.
                    Advices should thus be public. Private or protected advices is not supported. Package private advices
                    are not encouraged. Aspects classes should for the same purpose be public (or package private
                    thought not encouraged).
                </p>
            </subsection>
        </section>
        <section name="Advice">
            <p>
                    In the aspect class the advice are regular methods. The methods needs to conform to a specfic signature
                    unless
                <code>args()</code> selector is used in the pointcut the advice is bounded to.
                <ul>
                    <li>
                            For
                        <code>Around</code> advice:
                        <br/>
                        <code>public Object &lt;name of method&gt;(StaticJoinPoint staticJoinPoint) throws Throwable</code> signature.
                        <br/>
                        <code>public Object &lt;name of method&gt;(JoinPoint joinPoint) throws Throwable</code> signature.
                    </li>
                    <br/>
                    <li>
                            For
                        <code>Before</code> and
                        <code>After</code> advice:
                        <br/>
                        <code>public void &lt;name of method&gt;()</code> signature.
                        <br/>
                        <code>public void &lt;name of method&gt;(StaticJoinPoint staticJoinPoint)</code> signature.
                        <br/>
                        <code>public void &lt;name of method&gt;(JoinPoint joinPoint)</code> signature.
                    </li>
                </ul>
                    The advice can then be defined using XML or annotations, see the
                <a href="xml_definition.html">XML definition</a> section or the
                <a href="attribute_definition.html">Annotation definition</a> section for more information.
            </p>
            <p>
                Using StaticJoinPoint, JoinPoint or no JoinPoint at all is discussed in <a href="TODO">this section</a>.
            </p>
            <p>
            </p>
            <p>
                    Here is a simple example of an
                <code>Around</code> advice. (For more examples see the
                <a href="examples_2.html">Examples section</a>.) The
                <code>JoinPoint</code> object that is passed to
                    the method contains metadata and RTTI of the current
                    join point. To invoke the next advice in the chain (or the target method if there are no more advice)
                    simply call
                <code>joinPoint.proceed()</code> which will return the result from the next advice (or the target method).
            </p>
            <p>
                <source><![CDATA[
@Around myPointcut
public Object myAroundAdvice(JoinPoint joinPoint) throws Throwable {
    // do some stuff
    Object result = joinPoint.proceed();
    // do some more stuff
    return result;
}
            ]]></source>
            </p>
            <p>
                Note: for such a simple advice, StaticJoinPoint and staticJoinPoint.proceed() would be preferable.
            </p>
            <p>

            </p>
            <p>
                When using pointcut designators like args(..), this(..), target(..), or when using after returning or after throwing
                with a type binding, advice signature will be pointcut dependant. Read more about it in <a href="TODO">this section</a>.
                This allows to gain direct access to the advised method/constructor/field set arguments.
                The Pointcut declaration itself will have a specific signature. The bounded advice(s) is then required to have those
                parameters in their signature as well. This allows to avoid using the RTTI interface as well as providing strong typing and
                implies better performance.
            </p>
            <p>
                Such an advice can be defined thru Annotations and thru XML. See the
                <a href="xml_definition.html">XML definition</a> section or the
                <a href="attribute_definition.html">Annotation definition</a> section for more information.
            </p>
            <p>
                The advice signature is thus depending on the pointcut signature, although the JoinPoint argument is mandatory.
                A sample could look like the following:
                <source><![CDATA[
// will match all method named "log" with a "java.lang.String" as sole parameter
@Expression execution(* log(..)) AND args(s)
Pointcut myPointcut(String s) {return null;}

@Before myPointcut(adviceArg)
public void myBeforeAdvice(JoinPoint joinPoint, String adviceArg) {...}

// it is possible to have the JoinPoint at any index in the advice parameter list
// though a best practice is to keep it at the first position
@Around myPointcut(adviceArg)
public Object myAroundAdvice(String adviceArg, JoinPoint joinPoint) {... joinPoint.proceed(); ...}

@After myPointcut(adviceArg)
public void myAfterAdvice(JoinPoint joinPoint, String adviceArg) {...}
                ]]></source>
            </p>
        </section>
        <section name="JoinPoint instance">
            <p>
                Each advice is passed the
                <code>JoinPoint</code> instance or <code>StaticJoinPoint</code> instance if it requires it. The
                <code>JoinPoint</code> class implements
                the join point concept, i.e. a well-defined point in the program flow and provides a reflective access API
                to it. The <code>StaticJoinPoint</code> class is a lightweight version without the reflective access API which
                allows for a better performance (at the pros/cons of less genericity).
            </p>
            <p>
                The
                <code>JoinPoint</code> instance contains static information and RTTI (runtime type information) about the join point we are
                currently executing over.
                The <code>StaticJoinPoint</code> instance contains only the static information.
                The static information (the signature) is retrieved through one of the
                <a href="#Signature interfaces">Signature interfaces</a> by invoking
                <code>getSignature()</code>.
                While the RTTI is retrieved through one of the
                <a href="#RTTI interfaces">RTTI interfaces</a>
                by invoking
                <code>getRtti(), getTarget(), getThis(), getCaller(), getCallee()</code>.
            </p>
            <p>
                The
                <code>JoinPoint</code> and <code>StaticJoinPoint</code>class have a method called
                <code>proceed()</code>, this method is used in
                <code>Around</code> advice to either:
                <ul>
                    <li>
                        Invoke the next advice in the chain.
                    </li>
                    <br/>
                    <li>
                        Invoke the target join point (if there are no more advice).
                    </li>
                </ul>
                The
                <code>proceed()</code> method returns the result from the method invocation and in the
                <code>Around</code> advice you have the option of either returning the value returned from the
                <code>proceed()</code> method or faking the value and returning something else.
            </p>
            <p>
                The
                <code>JoinPoint</code> class has some other interesting methods as well, see the JavaDoc for details.
            </p>
        </section>
        <section name="Signature interfaces">
            <p>
                The
                <code>Signature</code> interfaces are used for retrieving static
                about the join point we are currently executing at. The interfaces forms a hierarchy in which you can
                be both fine-grained and course-grained depending on you needs. Just cast to the appropriate interface.
            </p>
            <p>
                The
                <code>Signature</code> can be retrieved from the
                <code>JoinPoint</code> or <code>StaticJoinPoint</code> by invoking
                the
                <code>getSignature()</code> method.
            </p>
            <p>
                The interfaces are:
                <ul>
                    <li>
                        <code>org.codehaus.aspectwerkz.joinpoint.Signature</code>
                    </li>
                    <li>
                        <code>org.codehaus.aspectwerkz.joinpoint.MemberSignature</code>
                    </li>
                    <li>
                        <code>org.codehaus.aspectwerkz.joinpoint.CodeSignature</code>
                    </li>
                    <li>
                        <code>org.codehaus.aspectwerkz.joinpoint.MethodSignature</code>
                    </li>
                    <li>
                        <code>org.codehaus.aspectwerkz.joinpoint.ConstructorSignature</code>
                    </li>
                    <li>
                        <code>org.codehaus.aspectwerkz.joinpoint.FieldSignature</code>
                    </li>
                    <!-- TODO: uncomment when impl.
                    <li>
                        <code>org.codehaus.aspectwerkz.joinpoint.CatchClauseSignature</code>
                    </li>
                    -->
                </ul>
                See the JavaDoc for API details.
            </p>
        </section>
        <section name="RTTI interfaces">
            <p>
                The
                <code>Rtti</code> interfaces are used for retrieving RTTI (Runtime Type Information)
                about the join point we are currently executing at. The interfaces forms a hierarchy in which you can
                be both fine-grained and course-grained depending on you needs. Just cast to the appropriate interface.
            </p>
            <p>
                The
                <code>RTTI</code> can be retrieved from the
                <code>JoinPoint</code> by invoking
                the
                <code>getRtti()</code> method.
            </p>
            <p>
                The interfaces are:
                <ul>
                    <li>
                        <code>org.codehaus.aspectwerkz.joinpoint.Rtti</code>
                    </li>
                    <li>
                        <code>org.codehaus.aspectwerkz.joinpoint.MemberRtti</code>
                    </li>
                    <li>
                        <code>org.codehaus.aspectwerkz.joinpoint.CodeRtti</code>
                    </li>
                    <li>
                        <code>org.codehaus.aspectwerkz.joinpoint.MethodRtti</code>
                    </li>
                    <li>
                        <code>org.codehaus.aspectwerkz.joinpoint.ConstructorRtti</code>
                    </li>
                    <li>
                        <code>org.codehaus.aspectwerkz.joinpoint.FieldRtti</code>
                    </li>
                    <!-- uncomment when impl.
                    <li>
                        <code>org.codehaus.aspectwerkz.joinpoint.CatchClauseRtti</code>
                    </li>
                    -->
                </ul>
                See the JavaDoc for API details.
            </p>
        </section>
        <section name="Using the AspectContext class">
            <p>
                The
                <code>AspectContext</code> class provides methods for getting handles to various parts
                of the system, that can be used for introspection as well as redefinitions of the runtime system.
            </p>
            <p>
                To access the
                <code>AspectContext</code> in a specific aspect you have define a
                constructor that takes one
                <code>org.codehaus.aspectwerkz.AspectContext</code> as its only
                parameter. The system will then take care of passing in a
                <code>AspectContext </code> instance
                when the aspect is instantiated. This instance you can then use as you wish, store it in
                a member field etc.
            </p>
            <p>
                This class has many useful methods. For example:
                <source><![CDATA[
...
AspectContainer getContainer()

void setParameter(String name, String value)
String getParameter(String name)

void setMetaData(Object key, Object value)
Object getMetaData(Object key)

int getDeploymentModel()
...
                ]]></source>
            </p>
        </section>
        <section name="Introductions">
            <p>
                FIXME: Jonas can you do that part ?
            </p>
            <p>
                Introductions makes it possible to extend a class with a new interface and/or a new implementation
                (methods and fields).
                <code>AspectWerkz</code> supports two different types of introductions:
                <ul>
                    <li>
                        Interface introductions - in which you introduce an interface to the target class.
                    </li>
                    <br/>
                    <li>
                        Implementation introductions - where you introduce implementations to a target class.
                    </li>
                </ul>
            </p>
            <p>
                Implementation introductions (interface with concrete implementation), in
                <code>AspectWerkz</code> implemented as
                <i>Mixins</i>, are defined as public static inner classes of the aspect class or as regular POJOs outside
                the aspect class.
            </p>
            <p>
                It is mandatory for the inner class to be public, apart from this the only requirement is that the aspect
                needs to have either
                <b>no</b> constructor at all (meaning implicitly a default one)
                <b>or</b> one of these
                two different constructors defined:
                <ul>
                    <li>
                        a default no-argument constructor - only needed if the aspect has a other constructors that
                        takes parameters (apart from the one below if defined)
                    </li>
                    <br/>
                    <li>
                        a constructor that takes a
                        <code>org.codehaus.aspectwerkz.AspectContext</code> instance
                        as its only parameter - this is needed if you want to retrieve information about the runtime
                        system, access paramaters defined at deployment time, access meta-data etc.
                        See
                        <a href="#Using the AspectContext class">Using the AspectContext class</a> section
                        for details.
                    </li>
                    <br/>
                </ul>
                If a constructor of type 2 is found then it is used else the default constructor. If no default
                constructor can be found then an exception is thrown.
            </p>
            <p>
                The inner class implements the interface(s) to introduce on the target class.
            </p>
            <p>
                Example of an implementation introduction that will introduce the implemetatation of the inner class
                along with the interfaces the inner class implements to the target classes defined in the definition.
                <source><![CDATA[
public MyAspect {

    public static class MyIntroduction extends SuperIntroduction implements ToBeIntroduced {
        // methods to be introduced
        ...
    }
}
                ]]></source>
            </p>
            <subsection name="Implementation swapping">
                <p>
                    It is possible to replace the introduction implementation at runtime using a call like
                    <source><![CDATA[
SystemLoader.getSystem("systemId").getAspectManager().getMixin("test.attribdef.aspect.IntroductionTestAspect$MyImpl").
    swapImplementation("test.attribdef.aspect.IntroductionTestAspectMyImplReplacement");
                    ]]></source>
                </p>
                <p>
                    The swapped implementation must implement the introduced interfaces, but can be an anonymous class
                    or an aspect inner class. Only the default introduced implementation must be an inner class.
                </p>
            </subsection>
        </section>
        <section name="Example of an Aspect">
            <p>
                   This is a simple example showing how an aspect implementation with a couple of advice
                    and an introduction could look like (Note: annotations to define the aspects are ommitted here):
                <source><![CDATA[
public class MyAspect {

     public Object myAroundAdvice(StaticJoinPoint staticJoinPoint) throws Throwable {
         // do some stuff
         Object result = staticJoinPoint.proceed();
         // do some other stuff
         return result;
     }

     public void myBeforeAdvice(JoinPoint joinPoint) {
         // do some stuff
     }

     // the Mixin could be an outer class
     public static class MyIntroduction extends SuperMixin implements ContractualInterface {
         ... // introduced methods and fields
     }
}
                    ]]></source>
            </p>
        </section>
        <section name="Choosing a definition model">
            <p>
                The
                <a href="xml_definition.html">XML definition</a> allows to define the pointcut expressions in an external file.
                It can be used
                to provide aspects that needs to be tuned without an extra development phase (apart from editing an XML file).
                The main disadvantage with this approach is that the implementation is separated from the definition which
                makes the code harder to refactor, maintain and reuse.<br/>
                Using the XML definition is a bit more difficult as well when pointcuts have complex signature to expose
                runtime arguments and instances (args(..), this(..), target(..)).
            </p>
            <p>
                The
                <a href="attribute_definition.html">Annotation definition</a> allows you to have truly self-contained aspect components.
                Those are easier to maintain, refactor and reuse as well as build libraries upon. The drawbacks are when you are not using Java 5, it
                requires an additional post-compilation step to annotate them with the metadata. Moreover it
                introduces tighter coupling, and makes the aspect harder to configure. You would have to extend the aspect to refine it.
            </p>
            <p>
                We have exprerienced that a combination of both definition formats can be beneficial. For example define
                the reusable aspects and advice using annotations but do the pointcut definition in the external XML file.
                This allows you to make certain decisions later in the development cycle, for example at deployment time
                instead of at compile time.
            </p>
        </section>
    </body>
</document>
