<?xml version="1.0"?>
<document>
    <properties>
        <author email="jboner at codehaus dot org">jonas bon&#233;r</author>
        <author email="alex at gnilux dot com">alexandre vasseur</author>
        <title>Implementation issues</title>
    </properties>
    <body>

        <section name="Table of Contents">
            <p>
                <b>Implementation issues</b>
            </p>
            <p>
                This section documents the programming model for Aspects, Advices and Mixins
                in AspectWerkz.
            </p>
            <p>
                <ol>
                    <li>
                        <a href="#Aspects">Aspect models</a>
                    </li>
                    <li>
                        <a href="#Advice">Advice</a>
                    </li>
                    <li>
                        <a href="#JoinPoint instance">JoinPoint instance</a>
                    </li>
                    <li>
                        <a href="#Signature interfaces">Signature interfaces</a>
                    </li>
                    <li>
                        <a href="#RTTI interfaces">RTTI interfaces</a>
                    </li>
                    <li>
                        <a href="#Using the AspectContext class">Using the AspectContext class</a>
                    </li>
                    <li>
                        <a href="#Mixins">Mixins</a>
                    </li>
                    <li>
                        <a href="#Retrieval of Aspect instances">Retrieval of Aspect instances</a>
                    </li>
                    <li>
                        <a href="#Example of an Aspect">Example of an Aspect</a>
                    </li>
                    <li>
                        <a href="#Choosing a definition model">Choosing a definition model</a>
                    </li>
                </ol>
            </p>
        </section>
        <section name="Aspects">
            <p>
                In
                <code>AspectWerkz</code> any Java class can be an aspect (or more conceptually correct, can
                be defined to be
                <i>cross-cutting</i>), which means that it will become a unit of modularity
                for crosscutting concerns.
            </p>
            <p>
                They do not have to extend any special class or implement a specific interface, but can extend any
                class they want.
            </p>
            <p>
                The only requirement is that the aspect needs to have either
                <b>no</b> constructor at all
                (meaning implicitly a default one)
                <b>or</b> one of these two different constructors defined:
                <ul>
                    <li>
                        a default no-argument constructor - only needed if the aspect has a other constructors that
                        takes parameters (apart from the one below if defined)
                    </li>
                    <br/>
                    <li>
                        a constructor that takes a
                        <code>org.codehaus.aspectwerkz.AspectContext</code> instance
                        as its only parameter - this is needed if you want to retrieve information about the runtime
                        system, access paramaters defined at deployment time, access meta-data etc.
                        See
                        <a href="#Using the AspectContext class">Using the AspectContext class</a> section
                        for details.
                    </li>
                    <br/>
                </ul>
                If a constructor of type 2 is found then it is used else the default constructor. If no default
                constructor can be found then an exception is thrown.
            </p>
            <p>
                The aspect can then be defined using XML or annotations, see the
                <a href="xml_definition.html">XML definition</a> section or the
                <a href="attribute_definition.html">Annotation definition</a> section for more information.
            </p>
            <subsection name="Abstract aspects - aspect inheritance">
                <p>
                    Since the Aspects are pure Java classes, you have the possibility of
                    defining abstract aspects that you can reuse by implementing another aspect
                    that inherits the abstract aspect.
                </p>
                <p>
                    Aspect inheritance is exactly regular class inheritance. An abstract aspect
                    is defined using the
                    <code>abstract</code> keyword as a regular abstract class and is inherited
                    using the
                    <code>extends</code> keyword.
                </p>
                <p>
                    Nevertheless specific rules must be observed for advices represented as methods. Indeed, the advice
                    is likely to be invoked from the class it is applied to as a result of the weaving process.
                    Advices should thus be public. Private or protected advices is not supported. Package private advices
                    are not encouraged. Aspects classes should for the same purpose be public (or package private
                    thought not encouraged).
                </p>
            </subsection>
        </section>
        <section name="Advice">
            <p>
                    In the aspect class the advice are regular methods. The methods needs to conform to a specfic signature
                    unless
                <code>args()</code> selector is used in the pointcut the advice is bounded to.
                <ul>
                    <li>
                            For
                        <code>Around</code> advice:
                        <br/>
                        <code>public Object &lt;name of method&gt;(StaticJoinPoint staticJoinPoint) throws Throwable</code> signature.
                        <br/>
                        <code>public Object &lt;name of method&gt;(JoinPoint joinPoint) throws Throwable</code> signature.
                    </li>
                    <br/>
                    <li>
                            For
                        <code>Before</code> and
                        <code>After</code> advice:
                        <br/>
                        <code>public void &lt;name of method&gt;()</code> signature.
                        <br/>
                        <code>public void &lt;name of method&gt;(StaticJoinPoint staticJoinPoint)</code> signature.
                        <br/>
                        <code>public void &lt;name of method&gt;(JoinPoint joinPoint)</code> signature.
                    </li>
                </ul>
                    The advice can then be defined using XML or annotations, see the
                <a href="xml_definition.html">XML definition</a> section or the
                <a href="attribute_definition.html">Annotation definition</a> section for more information.
            </p>
            <p>
                Using StaticJoinPoint, JoinPoint or no JoinPoint at all is discussed in <a href="TODO">this section</a>.
            </p>
            <p>
            </p>
            <p>
                    Here is a simple example of an
                <code>Around</code> advice. (For more examples see the
                <a href="examples_2.html">Examples section</a>.) The
                <code>JoinPoint</code> object that is passed to
                    the method contains metadata and RTTI of the current
                    join point. To invoke the next advice in the chain (or the target method if there are no more advice)
                    simply call
                <code>joinPoint.proceed()</code> which will return the result from the next advice (or the target method).
            </p>
            <p>
                <source><![CDATA[
@Around myPointcut
public Object myAroundAdvice(JoinPoint joinPoint) throws Throwable {
    // do some stuff
    Object result = joinPoint.proceed();
    // do some more stuff
    return result;
}
            ]]></source>
            </p>
            <p>
                Note: for such a simple advice, StaticJoinPoint and staticJoinPoint.proceed() would be preferable.
            </p>
            <p>

            </p>
            <p>
                When using pointcut designators like args(..), this(..), target(..), or when using after returning or after throwing
                with a type binding, advice signature will be pointcut dependant. Read more about it in <a href="TODO">this section</a>.
                This allows to gain direct access to the advised method/constructor/field set arguments.
                The Pointcut declaration itself will have a specific signature. The bounded advice(s) is then required to have those
                parameters in their signature as well. This allows to avoid using the RTTI interface as well as providing strong typing and
                implies better performance.
            </p>
            <p>
                Such an advice can be defined thru Annotations and thru XML. See the
                <a href="xml_definition.html">XML definition</a> section or the
                <a href="attribute_definition.html">Annotation definition</a> section for more information.
            </p>
            <p>
                The advice signature is thus depending on the pointcut signature, although the JoinPoint argument is mandatory.
                A sample could look like the following:
                <source><![CDATA[
// will match all method named "log" with a "java.lang.String" as sole parameter
@Expression execution(* log(..)) AND args(s)
Pointcut myPointcut(String s) {return null;}

@Before myPointcut(adviceArg)
public void myBeforeAdvice(JoinPoint joinPoint, String adviceArg) {...}

// it is possible to have the JoinPoint at any index in the advice parameter list
// though a best practice is to keep it at the first position
@Around myPointcut(adviceArg)
public Object myAroundAdvice(String adviceArg, JoinPoint joinPoint) {... joinPoint.proceed(); ...}

@After myPointcut(adviceArg)
public void myAfterAdvice(JoinPoint joinPoint, String adviceArg) {...}
                ]]></source>
            </p>
        </section>
        <section name="JoinPoint instance">
            <p>
                Each advice is passed the
                <code>JoinPoint</code> instance or <code>StaticJoinPoint</code> instance if it requires it. The
                <code>JoinPoint</code> class implements
                the join point concept, i.e. a well-defined point in the program flow and provides a reflective access API
                to it. The <code>StaticJoinPoint</code> class is a lightweight version without the reflective access API which
                allows for a better performance (at the pros/cons of less genericity).
            </p>
            <p>
                The
                <code>JoinPoint</code> instance contains static information and RTTI (runtime type information) about the join point we are
                currently executing over.
                The <code>StaticJoinPoint</code> instance contains only the static information.
                The static information (the signature) is retrieved through one of the
                <a href="#Signature interfaces">Signature interfaces</a> by invoking
                <code>getSignature()</code>.
                While the RTTI is retrieved through one of the
                <a href="#RTTI interfaces">RTTI interfaces</a>
                by invoking
                <code>getRtti(), getTarget(), getThis(), getCaller(), getCallee()</code>.
            </p>
            <p>
                The
                <code>JoinPoint</code> and <code>StaticJoinPoint</code>class have a method called
                <code>proceed()</code>, this method is used in
                <code>Around</code> advice to either:
                <ul>
                    <li>
                        Invoke the next advice in the chain.
                    </li>
                    <br/>
                    <li>
                        Invoke the target join point (if there are no more advice).
                    </li>
                </ul>
                The
                <code>proceed()</code> method returns the result from the method invocation and in the
                <code>Around</code> advice you have the option of either returning the value returned from the
                <code>proceed()</code> method or faking the value and returning something else.
            </p>
            <p>
                The
                <code>JoinPoint</code> class has some other interesting methods as well, see the JavaDoc for details.
            </p>
        </section>
        <section name="Signature interfaces">
            <p>
                The
                <code>Signature</code> interfaces are used for retrieving static
                about the join point we are currently executing at. The interfaces forms a hierarchy in which you can
                be both fine-grained and course-grained depending on you needs. Just cast to the appropriate interface.
            </p>
            <p>
                The
                <code>Signature</code> can be retrieved from the
                <code>JoinPoint</code> or <code>StaticJoinPoint</code> by invoking
                the
                <code>getSignature()</code> method.
            </p>
            <p>
                The interfaces are:
                <ul>
                    <li>
                        <code>org.codehaus.aspectwerkz.joinpoint.Signature</code>
                    </li>
                    <li>
                        <code>org.codehaus.aspectwerkz.joinpoint.MemberSignature</code>
                    </li>
                    <li>
                        <code>org.codehaus.aspectwerkz.joinpoint.CodeSignature</code>
                    </li>
                    <li>
                        <code>org.codehaus.aspectwerkz.joinpoint.MethodSignature</code>
                    </li>
                    <li>
                        <code>org.codehaus.aspectwerkz.joinpoint.ConstructorSignature</code>
                    </li>
                    <li>
                        <code>org.codehaus.aspectwerkz.joinpoint.FieldSignature</code>
                    </li>
                    <li>
                        <code>org.codehaus.aspectwerkz.joinpoint.CatchClauseSignature</code>
                    </li>
                </ul>
                See the JavaDoc for API details.
            </p>
        </section>
        <section name="RTTI interfaces">
            <p>
                The
                <code>Rtti</code> interfaces are used for retrieving RTTI (Runtime Type Information)
                about the join point we are currently executing at. The interfaces forms a hierarchy in which you can
                be both fine-grained and course-grained depending on you needs. Just cast to the appropriate interface.
            </p>
            <p>
                The
                <code>RTTI</code> can be retrieved from the
                <code>JoinPoint</code> by invoking
                the
                <code>getRtti()</code> method.
            </p>
            <p>
                The interfaces are:
                <ul>
                    <li>
                        <code>org.codehaus.aspectwerkz.joinpoint.Rtti</code>
                    </li>
                    <li>
                        <code>org.codehaus.aspectwerkz.joinpoint.MemberRtti</code>
                    </li>
                    <li>
                        <code>org.codehaus.aspectwerkz.joinpoint.CodeRtti</code>
                    </li>
                    <li>
                        <code>org.codehaus.aspectwerkz.joinpoint.MethodRtti</code>
                    </li>
                    <li>
                        <code>org.codehaus.aspectwerkz.joinpoint.ConstructorRtti</code>
                    </li>
                    <li>
                        <code>org.codehaus.aspectwerkz.joinpoint.FieldRtti</code>
                    </li>
                    <li>
                        <code>org.codehaus.aspectwerkz.joinpoint.CatchClauseRtti</code>
                    </li>
                </ul>
                See the JavaDoc for API details.
            </p>
        </section>
        <section name="Using the AspectContext class">
            <p>
                The
                <code>AspectContext</code> class provides methods for getting handles to various parts
                of the system, that can be used for introspection as well as redefinitions of the runtime system.
            </p>
            <p>
                To access the
                <code>AspectContext</code> in a specific aspect you have define a
                constructor that takes one
                <code>org.codehaus.aspectwerkz.AspectContext</code> as its only
                parameter. The system will then take care of passing in a
                <code>AspectContext </code> instance
                when the aspect is instantiated. This instance you can then use as you wish, store it in
                a member field etc.
            </p>
            <p>
                This class has many useful methods. For example:
                <source><![CDATA[
...
AspectContainer getContainer()

void setParameter(String name, String value)
String getParameter(String name)

void setMetaData(Object key, Object value)
Object getMetaData(Object key)

int getDeploymentModel()
...
                ]]></source>
            </p>
        </section>
        <section name="Mixins">
         <p>
             We have replaced the old mixin implementation with a comletely new and better one.
             The new implementation mainly gives you two things you did not have before:
             <ul>
                 <li>
                     Serialization of the Mixins -
                     <br/>
                     The default behaviour is that the mixins will be serialized along with the target class.
                     But you have the option of making the mixins <code>transient</code> (e.g. not serialized with
                     when the target class is serialized), by setting the <code>transient=true</code> flag.
                 </li>
                 <br/>
                 <li>
                     Providing your own factory to control the instantiation of the mixin. This means that you
                     can plug in any IoC (dependency injection) framework to handle this for you. The custom
                     factories needs only to implement the <code>org.codehaus.aspectwerkz.aspect.MixinFactory</code>
                     interface.
                 </li>
             </ul>
         </p>
         <p>
             The mixins can be any regular class, which means that it can be a standalone class, an inner class
             of a regular class or an inner class in your aspect class.
         </p>
         <p>
             Two different <code>deployment models</code> are supported, <code>perClass</code> and <code>perInstance</code>.
             <ul>
                 <li>
                     <code>perClass</code> - means that there will be one instance per mixin per
                     target class.
                 </li>
                 <li>
                     <code>perInstance</code> - means that there will be one instance per mixin per
                     target instance.
                 </li>
             </ul>
             Note: the <code>perThread</code> deployment model has been left to die in peace. The <code>perJVM</code>
             deployment model is currently not supported but might come back.
         </p>
         <p>
             If you are using the default factory implementation you have to either provide an no argument constructor
             or a constructor that takes the:
             <ul>
                 <li>
                     target class as its only parameter - to be used with the <code>perClass</code> deployment model.
                 </li>
                 <li>
                     target instance as its only parameter - to be used with the <code>perInstance</code> deployment model.
                 </li>
             </ul>
         </p>

         <subsection name="Annotation definition">
             <p>
                 To define the mixin using annotations you have to use the
                 <code>org.codehaus.aspectwerkz.annotation.Mixin</code> annotation.
                 If using Java 5 this is an annotation interface (e.g. <code>@interface</code>) else
                 (for JavaDoc annotations) it is a regular interface.
             </p>
             <p>
                 This annotation has three different parameters:
                 <ul>
                     <li>
                         <code>expression</code> (can be used as the default anonymous value) - the pointcut expression that is used to pick out the set of classes
                         to apply this mixin to.
                     </li>
                     <li>
                         <code>deploymentModel</code> (optional) - has to me one of <code>perClass</code> or
                         <code>perInstance</code>. If not specified then <code>perInstance</code> is used.
                     </li>
                     <li>
                         <code>isTransient</code> (optional) - defines the mixin as transient or not. If not
                         specified then the default is <code>false</code>, e.g. serializable.
                     </li>
                 </ul>
             </p>
             <p>
                 <b>Definition using Java 5 annotations</b>
                 <source><![CDATA[
 @Mixin("within(*..domain.*)")
 public class MyMixin { ... }

 @Mixin(
 pointcut="within(*..domain.*)",
 deploymentModel="perClass",
 isTransient=true
 )
 public class MyOtherMixin { ... }
                 ]]></source>
             </p>
             <p>
                <b>Definition using JavaDoc annotations</b>
                 <source><![CDATA[
 /** @Mixin("within(*..domain.*)") */
 public class MyMixin { ... }

 /**
  * @Mixin(
  *   pointcut="within(*..domain.*)",
  *   deploymentModel="perClass",
  *   isTransient=true
  * )
  */
 public class MyOtherMixin { ... }
                 ]]></source>
             </p>
         </subsection>

         <subsection name="XML definition">
             <p>
                 The XML definition (in the <code>META-INF/aop.xml</code> file) can be used for
                 three different purposes:
                 <ul>
                     <li>
                         Only to define which mixins should be used. Similar to how you declare which aspects
                         should be used.) This can be the option if the mixin is defined in annotations.
                         Then you only need to use the <code>class</code> attribute, e.g.
                         <code>&lt;mixin class="foo.bar.MyMixinImpl"/&gt;</code>. See below for details.
                     </li>
                     <li>
                         To completely define the mixin. See below for all the attributes that can be used.
                     </li>
                     <li>
                         To override and/or resolve ad definition made using annotations.
                         See below for all the attributes that can be used.
                     </li>
                 </ul>
             </p>
             <p>
                 To define the mixin using the XML definition, use the <code>mixin</code> element. It has
                 five different attributes that can be used:
                 <ul>
                     <li>
                         <code>class</code> (mandatory) - defines which class to use as the implementation class.
                         Has to be the fully qualified name of the class.
                     </li>
                     <li>
                         <code>deployment-model</code> (optional) - defines the deployment model. Can be one of
                         <code>perClass</code> of <code>perInstance</code>.
                     </li>
                     <li>
                         <code>transient</code> (optional) - defines the mixin as <code>transient</code> or not.
                     </li>
                     <li>
                         <code>factory</code> (optional) - defines the custom mixin factory implementation to use
                         with the specific mixin.
                     </li>
                     <li>
                         <code>bind-to</code> (optional) - defines to which class set the mixin should be applied to.
                     </li>
                 </ul>
             </p>
             <p>
                Example:
                 <source><![CDATA[
 <mixin class="foo.bar.MyMixinImpl"/>

 <mixin class="foo.bar.MyOtherMixinImpl"
    deployment-model="perClass"
    transient="true"
    factory="factories.MyMixinFactory"
    bind-to="within(*..domain.*)"/>
                 ]]></source>
             </p>
         </subsection>

         <subsection name="Custom Mixin factory">
             <p>
                 If you need to be in control of how hte aspects are instantiated and/or need to pass in
                 additional dependencies or configuration using an IoC (dependency injection) framework or similar.
                 Then you can create custom mixin factory.
             </p>
             <p>
                 The custom factories needs to implement the <code>org.codehaus.aspectwerkz.aspect.MixinFactory</code>:
                 <source><![CDATA[
 public interface MixinFactory {

 /**
  * Creates a new perClass mixin instance, if it already exists then return it.
  *
  * @param the target class
  * @return the mixin instance
  */
 Object mixinOf(Class klass);

 /**
  * Creates a new perInstance mixin instance, if it already exists then return it.
  *
  * @param the target instance
  * @return the mixin instance
  */
 Object mixinOf(Object instance);
 }
                 ]]></source>
             </p>
             <p>
                 The custom mixin factory can only be defined in the <code>mixin</code> element in the
                 <code>META-INF/aop.xml</code> file.
             </p>

            </subsection>

            <subsection name="Retrieval of Mixin instances">
                <p>
                    You can get a hold of the mixin instances for a specific instance or class through the
                    <code>org.codehaus.aspectwerkz.aspect.management.Mixins</code> class.
                </p>
                <p>
                Example:
                    <source><![CDATA[
// get per class deplolyed mixin
Object perclassMixin = Mixins.mixinOf(MyMixin.class, Target.class);

// get per instance deplolyed mixin
Object perinstanceMixin = Mixins.mixinOf(MyMixin.class, targetInstance);
                    ]]></source>
                </p>
            </subsection>
        </section>

    <section name="Retrieval of Aspect instances">
        <p>
            You can get a hold of specific aspect instances using the
            <code>org.codehaus.aspectwerkz.aspect.management.Aspects</code> class.
        </p>
        <p>
        Example:
            <source><![CDATA[
// get per jvm deployed aspect
Object singletonAspect = Aspects.aspectOf(MyAspect.class);
               ... = Aspects.aspectOf("uniqueNameOfAspect");

// get per class deployed aspect
Object perclassAspect = Aspects.aspectOf(MyAspect.class, Target.class);
              ... = Aspects.aspectOf("uniqueNameOfAspect", Target.class);

// get per instance deployed aspect
Object perinstanceAspect = Aspects.aspectOf(MyAspect.class, targetInstance);
                 ... = Aspects.aspectOf("uniqueNameOfAspect", targetInstance);
            ]]></source>
        </p>
    </section>

        <section name="Example of an Aspect">
            <p>
                   This is a simple example showing how an aspect implementation with a couple of advice
                    and an introduction could look like (Note: annotations to define the aspects are ommitted here):
                <source><![CDATA[
public class MyAspect {

     public Object myAroundAdvice(StaticJoinPoint staticJoinPoint) throws Throwable {
         // do some stuff
         Object result = staticJoinPoint.proceed();
         // do some other stuff
         return result;
     }

     public void myBeforeAdvice(JoinPoint joinPoint) {
         // do some stuff
     }

     // the Mixin could be an outer class
     public static class MyIntroduction extends SuperMixin implements ContractualInterface {
         ... // introduced methods and fields
     }
}
                    ]]></source>
            </p>
        </section>

        <section name="Choosing a definition model">
            <p>
                The
                <a href="xml_definition.html">XML definition</a> allows to define the pointcut expressions in an external file.
                It can be used
                to provide aspects that needs to be tuned without an extra development phase (apart from editing an XML file).
                The main disadvantage with this approach is that the implementation is separated from the definition which
                makes the code harder to refactor, maintain and reuse.<br/>
                Using the XML definition is a bit more difficult as well when pointcuts have complex signature to expose
                runtime arguments and instances (args(..), this(..), target(..)).
            </p>
            <p>
                The
                <a href="attribute_definition.html">Annotation definition</a> allows you to have truly self-contained aspect components.
                Those are easier to maintain, refactor and reuse as well as build libraries upon. The drawbacks are when you are not using Java 5, it
                requires an additional post-compilation step to annotate them with the metadata. Moreover it
                introduces tighter coupling, and makes the aspect harder to configure. You would have to extend the aspect to refine it.
            </p>
            <p>
                We have exprerienced that a combination of both definition formats can be beneficial. For example define
                the reusable aspects and advice using annotations but do the pointcut definition in the external XML file.
                This allows you to make certain decisions later in the development cycle, for example at deployment time
                instead of at compile time.
            </p>
        </section>
    </body>
</document>
