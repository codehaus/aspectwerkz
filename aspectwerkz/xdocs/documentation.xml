<?xml version="1.0"?>
<document>

    <properties>
        <author email="jboner at codehaus dot org">jonas bon&#233;r</author>
        <title>Documentation</title>
    </properties>

    <body>
        <section name="Table of Contents">
            <p>
                <ol>
                    <li>
                        <a href="#Introduction">Introduction</a>
                    </li>
                    <li>
                        <a href="#Advices">Advices</a>
                    </li>
                    <li>
                        <a href="#Introductions">Introductions</a>
                    </li>
                    <li>
                        <a href="#Pointcuts">Pointcuts</a>
                    </li>
                    <li>
                        <a href="#Aspects">Aspects</a>
                    </li>
                    <li>
                        <a href="#Join points">Join points</a>
                    </li>
                    <li>
                        <a href="#Join point selection pattern language">Join point selection pattern language</a>
                    </li>
                    <li>
                        <a href="#Passing parameters to advices">Passing parameters to advices</a>
                    </li>
                    <li>
                        <a href="#Advice stacks">Advice stacks</a>
                    </li>
                    <li>
                        <a href="#Example of an XML definition">Example of an XML definition</a>
                    </li>
                    <li>
                        <a href="#Startup and transformation issues">Startup and transformation issues</a>
                    </li>
                    <li>
                        <a href="#Loading the definition">Loading the definition</a>
                    </li>
                    <li>
                        <a href="#Weave model compilation">Weave model compilation</a>
                    </li>
                    <li>
                        <a href="#Runtime attributes">Runtime attributes</a>
                    </li>
                    <li>
                        <a href="#Hot deployment and reconfiguration">Hot deployment and reconfiguration</a>
                    </li>
                    <li>
                        <a href="#Deployment models">Deployment models</a>
                    </li>
                    <li>
                        <a href="#Thread safety">Thread safety</a>
                    </li>
                    <li>
                        <a href="#Meta data">Meta data</a>
                    </li>
                    <li>
                        <a href="#Multiple weave models in one JVM">Multiple weave models in one JVM</a>
                    </li>
                    <li>
                        <a href="#Pluggable container implementation">Pluggable container implementation</a>
                    </li>
                </ol>
            </p>

        </section>

        <section name="Introduction">
            <p>
                This is a brief outline of the main concepts in the
                <code>AspectWerkz</code> framework and how they are used.
            </p>
            <p>
                You most likely <b>not</b> learn Aspect-Oriented Programming
                by only reading this paper. If you are a beginner I would
                recommend that you first read some introductory articles on the
                subject.
            </p>
            <p>
                <code>AspectWerkz</code> is a dynamic, lightweight and
                high-performant AOP framework for Java. It utilizes the
                <a href="http://javalab.cs.uni-bonn.de/research/jmangler">JMangler</a>
                framework for load-time transformation of Java class files and the
                <a href="http://jakarta.apache.org/bcel">BCEL</a> library for
                bytecode manipulation of Java classes. It hooks in directly after
                the bootstrap class loader and can perform bytecode transformations
                on classes loaded by all the preceeding class loaders. The target
                classes can be regular POJOs.
            </p>
        </section>

        <section name="Advices">
            <p>
                The <code>Advice</code> class implements the advice concept,
                i.e. defines code that is executed when a join point is reached.
            </p>

            <subsection name="Implementation">
                <p>
                    There are currently four types of Advices supported:
                    <ul>
                        <li>
                            <code>AroundAdvice</code> - is invoked "around" the
                            join point. Can be used to intercept method
                            invocations.
                        </li><br/>
                        <li>
                            <code>PreAdvice</code> - is invoked before the join
                            point. Can be used for advising fields or caller side
                            pointcuts.
                        </li><br/>
                        <li>
                            <code>PostAdvice</code> - is invoked after the join
                            point. Can be used for advising fields or caller side
                            pointcuts.
                        </li><br/>
                        <li>
                            <code>ThrowsAdvice</code> - advises join points
                            where an exception is thrown out of a method.
                        </li>
                    </ul>
                </p>

                <p>
                    <b>AroundAdvice</b>
                </p>
                 <p>
                    An <code>AroundAdvice</code> is implemented by extending
                    the <code>AroundAdvice</code> class and implementing the
                    abstract method <code>Object execute(final JoinPoint jp)</code>.
                </p>
                <p>
                    Here is a simple example of an <code>AroundAdvice</code>.
                    (For more examples see the
                    <a href="/examples.html">Examples section</a>.)
                    <br/>
                    It is in the method <code>execute</code> that the action
                    takes place. The <code>JoinPoint</code> object that is
                    passed to the method contains metadata of the current
                    join point. To invoke the next advice in the chain (or the
                    target method if there are no more advices) simply call
                    <code>joinPoint.proceed()</code>. This method will return
                    the result from the next advice (or the target method).
                </p>
<source><![CDATA[
public class MyAroundAdvice extends AroundAdvice {
    public MyAroundAdvice() {
        super();
    }
    public Object execute(final JoinPoint joinPoint) throws Throwable {
        // do some stuff
        Object result = joinPoint.proceed();
        // do some more stuff
        return result;
    }
}]]></source><br/>
                <p>
                    <b>PreAdvice</b>
                </p>
                <p>
                    A <code>PreAdvice</code> is implemented by extending either
                    the abstract <code>PreAdvice</code> class and implementing
                    the abstract method <code>void execute(final JoinPoint jp)</code>.
                    The <code>PreAdvice</code> class is being executed before
                    the join point (that it has been applied to) has been is reached.
                </p>
                <p>
                    Here is a simple example of a <code>PreAdvice</code> advice.
                    It is in the method <code>execute</code> that you can implement
                    your logic. The <code>JoinPoint</code> object that is
                    passed to the method contains metadata for the current
                    join point. There is no need to call <code>joinPoint.proceed()</code>
                    for either <code>PreAdvices</code> or <code>PostAdvices</code>.
                </p>
<source><![CDATA[
public class MyPreAdvice extends PreAdvice {
    public MyPreAdvice() {
        super();
    }
    public void execute(final JoinPoint joinPoint) throws Throwable {
        // do some stuff
    }
}
]]></source><br/>
                <p>
                    <b>PostAdvice</b>
                </p>
                <p>
                    A <code>PostAdvice</code> is implemented by extending either
                    the abstract <code>PostAdvice</code> class and implementing
                    the abstract method <code>void execute(final JoinPoint jp)</code>.
                    The <code>PreAdvice</code> class is being executed before
                    the join point (that it has been applied to) has been is reached.
                </p>
                <p>
                    Here is a simple example of a <code>PostAdvice</code> advice.
                    It is in the method <code>execute</code> that you can implement
                    your logic. The <code>JoinPoint</code> object that is
                    passed to the method contains metadata for the current
                    join point. There is no need to call <code>joinPoint.proceed()</code>
                    for either <code>PreAdvices</code> or <code>PostAdvices</code>.
                </p>
<source><![CDATA[
public class MyPostAdvice extends PostAdvice {
    public MyPostAdvice() {
        super();
    }
    public void execute(final JoinPoint joinPoint) throws Throwable {
        // do some stuff
    }
}
]]></source><br/>
                <p>
                    <b>ThrowsAdvice</b>
                </p>
                <p>
                    A <code>ThrowsAdvice</code> is implemented by extending the
                    the <code>ThrowsAdvice</code> class and implementing the abstract
                    method <code>void execute(final JoinPoint jp)</code>.
                    The <code>ThrowsAdvice</code> class is being executed
                    after the join point (that it has been applied to) has been
                    reached. I.e. when a specific exception has been thrown out
                    of a specific method.
                </p>
                <p>
                    Here is a simple example of a <code>ThrowsAdvice</code> advice.
                    It is in the method <code>execute</code> that you can implement
                    your logic. The <code>JoinPoint</code> object that is passed to
                    the method contains metadata of the current join point.
                </p>
<source><![CDATA[
public class MyThrowsAdvice extends ThrowsAdvice {
    public MyThrowsAdvice() {
        super();
    }
    public void execute(final JoinPoint joinPoint) throws Throwable {
        Throwable cause = ((ThrowsJoinPoint)joinPoint).getException());
        // do some stuff
    }
}
]]></source>
           </subsection>

            <subsection name="Definition">
                <p>
                    <b>Attributes</b>
                </p>
                <p>
                    When defining the advices there are three attributes that
                    needs to be specified:
                </p>
                <p>
                    <ul>
                        <li>
                            <code>name</code> -
                            for each advice you first have define the name of the
                            advice. This name has to be unique and will work as a handle
                            to the advice to be used when referencing the advice in the
                            system.
                        </li><br/>
                        <li>
                            <code>advice</code> -
                            secondly you have to define the class name of the advice
                            that the name attribute should be mapped to.
                        </li><br/>
                        <li>
                            <code>deployment-model</code> -
                            last we have an optional attribute specifying the deployment
                            model to use. If no deployment model is defined the default
                            perJVM (singleton) will be used.
                            (For more information about the deployment model
                            types available see the
                            <a href="#Deployment Models">Deployment models section</a>).
                        </li><br/>
                    </ul>
                </p>

                <p>
                    Here you also have the possibility to pass parameters to
                    the advices. See the
                    <a href="#Passing parameters to advices">Passing parameters to advices</a>
                    section for a detailed description.
                </p>
                <p>
                    <b>XML definition</b>
                </p>
                <p>
<source><![CDATA[
<advice-def name="advices/caching"
            class="advices.CachingAdvice"
            deployment-model="perInstance">
    <param name="timeout" value="10"/>
</advice>
]]></source>
                </p>
            </subsection>
        </section>

        <section name="Introductions">
            <p>
                The <code>Introduction</code> class implements the concept of
                Mixins/Open Classes. I.e. an <code>Introduction</code> makes it
                possible to extend a class with a new interface and/or a new
                implementation (methods and fields).
            </p>

            <subsection name="Implementation">
                <p>
                    Both the interface and the implementation extensions are just
                    regular Java interfaces and classes. There is no need to have
                    them implement a specific interface or extend a certain class.
                    All you have to do is define them. The only rules are
                    that the introduced implementation has to implement the
                    introduced interface and have a default no-argument constructor.
                </p>
                <p>
                    When defining an interface introduction you only have to specify
                    the interface, but when introducing a new implementation to a
                    class, you must specifiy both the implementation class a
                    matching interface. This is needed since if you don't specify
                    an interface that the client can cast the target object to,
                    the introduced implementation will not be accessible.
                </p>
                <p>
                    Note: if you add more than one <code>Introduction</code> to
                    a target class then <b>you</b> have to make shure that the
                    names of the methods does not collide (or you will get
                    strange results).
                </p>
            </subsection>

            <subsection name="Definition">
                <p>
                    <b>Attributes</b>
                </p>
                <p>
                    When defining the introductions there are four attributes
                    that needs to be specified:
                </p>
                <p>
                    <ul>
                        <li>
                            <code>name</code> -
                            each introduction needs to have a unique name that will work
                            as a handle to the advice to be used when referencing the
                            introduction in the system.
                        </li><br/>
                        <li>
                            <code>interface</code> -
                            this attribute specifies the full name of the interface class
                            to use.
                        </li><br/>
                        <li>
                            <code>implementation</code> -
                            this attribute specifies the full name of the implementation
                            class to use. (Is skipped when we are defining an interface
                            introduction).
                        </li><br/>
                        <li>
                            <code>deployment-model</code> -
                            is an optional attribute specifying the deployment model
                            to use. If no deployment model is defined the default perJVM
                            (singleton) will be used. (For more information about
                            the deployment model types available see the
                            <a href="#Deployment Models">Deployment models section</a>).
                        </li>
                    </ul>
                </p>

                <p>
                    <b>XML definition</b>
                </p>
                <p>
<source><![CDATA[
<introduction-def name="java/io/Serializable"
                  interface="java.io.Serializable"/>

<introduction-def name="mixins/Mixin"
                  interface="mixins.Mixin"
                  implementation="mixins.MixinImpl"
                  deployment-model="perThread"/>
]]></source>
                </p>
                <p>
                    (These examples only shows how to define the
                    <code>Introduction</code>, for examples how to add them see
                    the <a href="#Aspects">Aspects section</a>.)
                </p>
            </subsection>
        </section>


        <section name="Pointcuts">
            <p>
                The <code>Pointcut</code> class implements the pointcut concept.
                Pointcuts selects join points and values at those points,
                i.e. selects well-defined points in the program flow.
            </p>

            <subsection name="Implementation">
                <p>
                    There are currently four different types of pointcuts supported:
                    <ul>
                        <li>
                            <code>MethodPointcut</code> - picks out join points
                            defining method execution.
                        </li><br/>
                        <li>
                            <code>FieldPointcut</code> - picks out join points
                            defining field access or modification.
                        </li><br/>
                        <li>
                            <code>ThrowsPointcut</code> - picks out join points
                            definining where an exception is thrown out of a
                            method.
                        </li><br/>
                        <li>
                            <code>CallerSidePointcut</code> - picks out join points
                            defining method invocation on the caller side.
                        </li><br/>
                        <li>
                            <code>CFlowPointcut</code> - picks out join points
                            defining a control flow (cflow).
                        </li>
                    </ul>
                </p>
                <p>

                </p>
            </subsection>

            <subsection name="Definition">
                <p>
                    <b>Attributes</b>
                </p>
                <p>
                    When defining the pointcuts there are three attributes
                    that needs to be specified:
                </p>
                <p>
                    <ul>
                        <li>
                            <code>name</code> -
                            specifies the name of the pointcut. Needs to be a unique
                            name throughout the aspect definintion.
                            <br/>
                            Caution: names must only consist of these characters:
                            <code>[A-Z]</code>, <code>[a-z]</code>, <code>[0-9]</code>
                            and the characters <code>$</code> and <code>_</code>.
                        </li>
                        <li>
                            <code>type</code> -
                            specifies the type of the pointcut.
                            <p>
                                Valid types are (all lowercase is also valid):
                                <ul>
                                    <li>
                                        <code>method</code>
                                    </li>
                                    <li>
                                        <code>setField</code>
                                    </li>
                                    <li>
                                        <code>getField</code>
                                    </li>
                                    <li>
                                        <code>throws</code>
                                    </li>
                                    <li>
                                        <code>callerSide</code>
                                    </li>
                                    <li>
                                        <code>cflow</code>
                                    </li>
                                </ul>
                            </p>
                        </li>
                        <li>
                            <code>pattern</code> -
                            specifies the pattern for the pointcut. This is the
                            pattern that picks out the join points that should be
                            included in the pointcut.
                            <p/>
                            For the <code>ThrowsPointcut</code>
                            the pattern is defined like this:
                            <code>methodPattern#fullyQualifiedNameOfException</code>.
                            <p/>
                            For the <code>CallerSidePointcut</code>
                            the pattern is defined like this:
                            <code>callerSideClassPattern->calleeSideMethodPattern</code>.
                            <p/>
                            See the
                            <a href="#Join point selection pattern language">Join point selection pattern language</a>
                            section for a detailed description on how these
                            patterns work and are used.
                            <p/>
`                        </li><br/>
                    </ul>
                </p>

                <p>
                    <b>XML definition</b>
                </p>
                <p>
<source><![CDATA[
<aspect ...>
    <pointcut-def name="pc1" type="method" pattern="* foo.Bar.method(..)"/>
    <pointcut-def name="pc2" type="setField" pattern="* foo.Bar.m_field"/>
    <pointcut-def name="pc3" type="throws" pattern="* foo.Bar.method(..)#java.lang.Exception"/>
    <pointcut-def name="pc4" type="callerSide" pattern="foo.Caller->String foo.Callee.method()"/>
    <pointcut-def name="pc5" type="cflow" pattern="* Transaction.begin(..)"/>
    ...
</aspect>
]]></source>
                </p>
            </subsection>

        </section>

        <section name="Aspects">
            <p>
                The <code>Aspect</code> class implements the aspect concept.
                Aspects are <code>AspectWerkz's</code> unit of modularity for
                crosscutting concerns. They are defined in terms of pointcuts,
                advices and introductions.
            </p>

            <subsection name="Definition">
                <p>
                    <b>Abstract aspects - aspect inheritance</b>
                </p>
                <p>
                    You have the possibility of defining abstract aspects that you
                    can reuse by letting aspects inherit the the abstract aspect using
                    the <code>extends</code> attribute. Aspect inheritance works
                    pretty much like regular class inheritance. An abstract aspect
                    is defined using the <code>abstract-aspect</code> element.
                </p>
                <p>
                    <b>Attributes</b>
                </p>
                <p>
                    When defining the aspects there is first one attribute
                    that needs to be specified:
                </p>
                <p>
                    <ul>
                        <li>
                            <code>name</code> - specifies a unique name for the aspect.
                        </li><br/>
                        <li>
                            <code>extends</code> - specifies the abstract aspect that
                            the aspect extends (optional).
                        </li><br/>
                   </ul>
                </p>

                <p>
                    <b>Adding the pointcuts definitions</b>
                </p>
                <p>
                    In the aspect definition you put the pointcut definitions (see the
                    <a href="#Pointcuts">Pointcuts section</a>).
                </p>
                <p>
                    <b>Adding the introductions</b>
                </p>
                <p>
                    Then you specify the introductions that you want to define
                    in this <code>aspect</code>. This is done using the
                    <code>introduction</code> element.
                </p>
                <p>
                    This element has an attribute <code>class</code> where you define
                    the pattern for the classes that you want to be applied by this/these
                    introductions. Within this element you define the references to the introductions.
                    Using the <code>introduction-ref</code> element:
                    <code>&lt;introduction-ref name="nameOfIntroduction"/&gt;</code>
               </p>
                <p>
                    <b>Adding the advices</b>
                </p>
                <p>
                    You also define which advices should be applied to which pointcuts.
                    This is done using the <code>advice</code> element.
                </p>
                <p>
                    The <code>advice</code> element has an attribute called <code>expression</code>
                    (<code>pointcut</code> works fine as well) in which you can define an expression
                    based on the names of the pointcuts you have defined for this aspect.
                </p>
                <p>
                    This expression can be any (almost) kind of algebraic expression.
                    The only difference is that you have to use <code>OR</code> instead
                    of <code>||</code> and <code>AND</code> instead of <code>&amp;&amp;</code>
                    (lowercase works fine as well). AND is needed because it is cumbersome
                    to write &amp;&amp; in XML (needs to be escaped) and OR is used to make
                    it coherent;
                </p>
                <p>
                    Here you also define if the pointcut/expression should be a part of a
                    control flow using the <code>cflow</code> attribute. The <code>cflow</code>
                    is defined using its pointcut name.
                </p>
                <p>
                    <b>XML definition</b>
                </p>
                <p>
<source><![CDATA[
<abstract-aspect name="MyAbstractAspect">
    <advice cflow="facadeCalls" pointcut="setters AND !getters">
        <advices-ref name="log_and_cache"/>
    </advice>

    <advice pointcut="persistentFields">
        <advice-ref name="persistent"/>
    </advice>
</aspect>

<aspect name="MyAspect" extends="MyAbstractAspect">
    <introduction class="domain.*">
        <introduction-ref name="serializable"/>
        <introduction-ref name="mixin"/>
    </introduction>

    <pointcut-def name="facadeCalls" type="cflow" pattern="* *..facade.*.*(..)"/>
    <pointcut-def name="setters" type="method" pattern="String domain.*.set*(..)"/>
    <pointcut-def name="getters" type="method" pattern="String domain.*.get*(..)"/>
    <pointcut-def name="persistentFields" type="setField" pattern="* domain.*.*">
</aspect>
]]></source>
                </p>
            </subsection>
        </section>

        <section name="Join points">
            <p>
                The <code>JoinPoint</code> class implements the join point
                concept, i.e. a well-defined point in the program flow.
                A <code>JoinPoint</code> is picked out by a <code>Pointcut</code>.
            </p>

            <subsection name="Implementation">
                <p>
                    There are four different types of join points:
                    <ul>
                        <li>
                            <code>MethodJoinPoint</code>
                        </li><br/>
                        <li>
                            <code>FieldJoinPoint</code>
                        </li><br/>
                        <li>
                            <code>ThrowsJoinPoint</code>
                        </li><br/>
                        <li>
                            <code>CallerSideJoinPoint</code>
                        </li>
                    </ul>
                </p>

                <p>
                    You only have to deal with the different types of
                    join points when you in your <code>Advice</code> need to
                    cast the <code>JoinPoint</code> object to a specific type
                    to be able to retrieve meta-data from this specific join point.
                    See the JavaDoc for more information on what information is
                    available.
                </p>
            </subsection>

        </section>

        <section name="Join point selection pattern language">
            <p>
                <code>AspectWerkz</code> support a fine-grained pattern
                language for picking out join points.
            </p>

            <p>
                You can utilize two types of wildcards when constructing your
                patterns:
            </p>
             <p>
                 <ul>
                     <li>
                         <code>*</code> - which is used as a regular wildcard.
                         Matches for example only one package level or one method parameter.
                         Matches <b>at least one</b> character.
                     </li><br/>
                     <li>
                         <code>..</code> - matches any sequence of characters that
                         start and end with a ".", so it can be used to pick out all
                         types in any subpackage. For example <code>org.codehaus..*</code>
                         will match all classes in all subpackages starting from
                         <code>org.codehaus</code>.
                     </li>
                 </ul>
                 Note: you can only use the <code>..</code> wildcard as the
                 "last" thing specified. I.e. this is <b>not</b> possible:
                 <code>foo.bar..test.MyClass</code>, but this is:
                 <code>foo.bar..</code>. The same thing holds for method
                 parameters.
             </p>

            <subsection name="Combining the patterns">
                <p>
                    The patterns normally consists of a combination of a class and a method
                    pattern or a class and a field pattern.
                </p>
                <p>
                    Example of a full method pattern:<br/>
                    <code>&lt;return_type_pattern&gt; &lt;package_and_class_pattern&gt;.&lt;method_name_pattern&gt;(&lt;parameter_type_patterns&gt;)</code>
                </p>
                <p>
                    Example of a full field pattern:<br/>
                    <code>&lt;field_type_pattern&gt; &lt;package_and_class_pattern&gt;.&lt;field_name_pattern&gt;</code>
                </p>
            </subsection>

            <subsection name="Class selections">
                <p>
                    For the class selections specify the full package name of
                    the class along with some wildcards.
                </p>
                <p>
                    <b>Examples:</b>
                </p>
                <p>
                    <ul>
                        <li>
                            <code>foo.bar.*</code> - will match<br/>
                            <code>foo.bar.FooBar2</code> as well as<br/>
                            <code>foo.bar.FooBear</code>.
                        </li><br/>
                        <li>
                            <code>foo.*.FooBar</code> - will match<br/>
                            <code>foo.bar.FooBar2</code> as well as<br/>
                            <code>foo.bear.FooBar</code> but not<br/>
                            <code>foo.bear.FooBear</code>.
                        </li><br/>
                        <li>
                            <code>foo.*.FooB*</code> - will match<br/>
                            <code>foo.bar.FooBar2</code> as well as<br/>
                            <code>foo.bear.FooBear</code>.
                        </li>
                        <li>
                            <code>foo..</code> - will match<br/>
                            all classes in all packages starting with foo.
                        </li>
                    </ul>
                </p>
            </subsection>

            <subsection name="Method selections">
                <p>
                    The methods are selected by specifying a pattern that
                    consists of:
                </p>
                <p>
                    <ul>
                        <li>
                            return type
                        </li>
                        <li>
                            full name of method (including class and package)
                        </li>
                        <li>
                            parameter types
                        </li>
                    </ul>
                </p>
                <p>
                    All method patterns must follow this structure:<br/>
                    <code>&lt;return_type&gt; &lt;full_method_name&gt;(&lt;parameter_types&gt;)</code>
                </p>
                <p>
                    <b>Examples</b>
                </p>
                <p>
                    <ul>
                        <li>
                            <code>int foo.*.Bar.method()</code> - will match<br/>
                            <code>int method()</code> but not<br/>
                            <code>int method(int i)</code>.
                        </li><br/>
                        <li>
                            <code>int *.method(*)</code> - will match<br/>
                            <code>int Foo.method(int i)</code> but not<br/>
                            <code>int Foo.method()</code>.
                        </li><br/>
                        <li>
                            <code>int foo.*.*.method(*,int)</code> - will match<br/>
                            <code>int method(String s, int i)</code> as well as<br/>
                            <code>int method(int i1, int i2)</code>.
                        </li><br/>
                        <li>
                            <code>int foo.*.Bar.method(..)</code> - will match<br/>
                            <code>int method()</code> as well as<br/>
                            <code>int method(String s, int i)</code> as well as<br/>
                            <code>int method(int i, double d, String s, Object o)</code>.
                        </li><br/>
                        <li>
                            <code>int foo.*.Bar.method(int,..)</code> - will match<br/>
                            <code>int method(int)</code> as well as<br/>
                            <code>int method(int i, String s)</code> as well as<br/>
                            <code>int method(int i, double d, String s, Object o)</code>.
                        </li><br/>
                        <li>
                            <code>int foo.*.Bar.method(java.lang.*)</code> - will match<br/>
                            <code>int method(String s)</code> as well as<br/>
                            <code>int method(StringBuffer sb)</code>.
                        </li><br/>
                        <li>
                            <code>int foo.*.Bar.me*o*()</code> - will match<br/>
                            <code>int method()</code> as well as<br/>
                            <code>int metamorphosis()</code> but not<br/>
                            <code>int me()</code>.
                        </li><br/>
                        <li>
                            <code>* foo.*.Bar.method()</code> - will match<br/>
                            <code>int method()</code> as well as<br/>
                            <code>java.lang.String method()</code>.
                        </li><br/>
                        <li>
                            <code>java.lang.* foo.*.Bar.method()</code> - will match<br/>
                            <code>java.lang.String Bar.method()</code> as well as<br/>
                            <code>java.lang.StringBuffer Bar.method()</code>.
                        </li>
                    </ul>
                </p>
            </subsection>

            <subsection name="Field selections">
                <p>
                    The fields are selected by specifying a pattern that
                    consists of:
                </p>
                <p>
                    <ul>
                        <li>
                            field type
                        </li>
                        <li>
                            full name of field (including class and package)
                        </li>
                    </ul>
                </p>
                <p>
                    All field patterns must follow this structure:<br/>
                    <code>&lt;field_type&gt; &lt;full_field_name&gt;</code>
                </p>
                <p>
                    <b>Examples</b>
                </p>
                <p>
                    <ul>
                        <li>
                            <code>int foo.*.Bar.m_foo</code> - will match<br/>
                            <code>int m_foo</code> but not<br/>
                            <code>int s_foo</code> or<br/>
                            <code>long m_foo</code>.
                        </li><br/>
                        <li>
                            <code>* foo.*.Bar.m_foo</code> - will match<br/>
                            <code>int m_foo</code> as well as<br/>
                            <code>java.lang.String m_foo</code>.
                        </li><br/>
                        <li>
                            <code>java.lang.* foo.*.Bar.m_foo</code> - will match<br/>
                            <code>java.lang.String m_foo</code> as well as<br/>
                            <code>java.lang.StringBuffer m_foo</code>.
                        </li><br/>
                        <li>
                            <code>int foo.*.Bar.m_*</code> - will match<br/>
                            <code>int m_foo</code> as well as<br/>
                            <code>int m_bar</code>.
                        </li><br/>
                        <li>
                            <code>int foo.*.Bar.m_*oo*</code> - will match<br/>
                            <code>int m_foo</code> as well as<br/>
                            <code>int m_looser</code>.
                        </li>
                    </ul>
                </p>

            </subsection>

            <subsection name="Abbreviations">
                <p>
                    When picking out the return and parameter types it is
                    possible to use predefined abbreviations for the classes
                    in the <code>java.lang.*</code> and <code>java.util.*</code>
                    packages. If you specify only the class name it will be
                    mapped to the full class name for the class.
                </p>
                <p>
                    <b>Examples</b>
                </p>
                <p>
                    You can use:
                    <ul>
                        <li>
                            <code>String</code> instead of <code>java.lang.String</code>
                        </li>
                        <li>
                            <code>List</code> instead of <code>java.util.List</code>
                        </li>
                        <li>
                            and so on...
                        </li>
                    </ul>
                </p>
                <p>
                    Apart from these abbreviations you always have to specify
                    the fully qualified name of the class (along with the
                    wildcards).
                </p>
            </subsection>
        </section>

        <section name="Passing parameters to advices">
            <p>
                You also have the option of passing parameters to your advices.
                This can be very convenient if you want to reuse the same
                advice but with a different configuration. To pass a parameter
                to the advice you simply add a <code>param</code> tag to the
                advice definition, like this:
            </p>
            <p>
<source><![CDATA[
<advice-def ... >
    <param name="timeout" value="10"/>
</advice-def>
]]></source>
            </p>
            <p>
                If you prefer the <code>Runtime Attributes</code> way of
                defining your advices:
            </p>
            <p>
<source><![CDATA[
/**
 * ...
 * @aspectwerkz.advice-param advice-ref=advices/MyAdvice
 *                           name=timeout
 *                           value=10
 */
 public class MyAdvice extends AroundAdvice {..}
]]></source>
            </p>
            <p>
                You can pass as many parameters to your advices as you want.
            </p>
            <p>
                At runtime you can then retrieve the parameters in your
                <code>Advice</code> like this:
<source><![CDATA[
String timeOut = getParameter("timeout");
]]></source>
            </p>
        </section>

        <section name="Advice stacks">
            <p>
                An <code>advice stack</code> lets you define a stack/chain with
                advices that you can refer to in your pointcuts. The order of the
                advices in the stack is the same order as they will be executed
                in.
            </p>
            <p>
                Advice stacks can come in very handy when you have a bunch of
                advices that logically belongs together and are used in the same
                order at many places in the definition. If the order between the
                advices is critical then it is recommended that you arrange the
                advices using an <code>advice stack</code>,
                (or specifying them in the same pointcut in the order you want).
            </p>
            <p>
                If the order between some advices is critical then it is
                recommended that you arrange the advices using an
                <code>advice stack</code>.
            </p>
            <p>
                <b>Example</b>
            </p>
            <p>
                You define an <code>advice stack</code> using the <code>advices</code> element:
<source><![CDATA[
<advices-def name="advicestack">
    <advice-ref name="acl"/>
    <advice-ref name="logging"/>
    <advice-ref name="caching"/>
</advices-def>
]]></source>
            </p>
            <p>
                This <code>advice stack</code> can then be referenced in your
                <code>Pointcut</code>:
<source><![CDATA[
<advice pointcut="pc1">
    <advices-ref name="advicestack"/>
</advice>
]]></source>
            </p>

        </section>

        <section name="Example of an XML definition">
            <p>
                Here is an example where all the definitions are put together
                into a single <code>AspectWerkz</code> XML definition file.
            </p>
<source><![CDATA[
<?xml version="1.0"?>

<aspectwerkz>
    <!-- ============================================= -->
    <!--  Define the advices                           -->
    <!-- ============================================= -->
    <advice-def name="log"
                advice="advices.LoggingAdvice"
                deployment-model="perInstance"/>

    <advice-def name="cache"
                advice="advices.CachingAdvice"
                deployment-model="perClass"/>

    <advice-def name="persistent"
                advice="advices.PersistenceAdvice"
                deployment-model="perJVM"/>

    <advices-def name="log_and_cache">
        <advice-ref name="log"/>
        <advice-ref name="cache"/>
    </advices-def>

    <!-- ============================================= -->
    <!--  Define the introductions                     -->
    <!-- ============================================= -->
    <introduction-def name="serializable"
                      interface="java.io.Serializable"/>

    <introduction-def name="mixin"
                      interface="mixins.Mixin"
                      implementation="mixins.MixinImpl"
                      deployment-model="perInstance"/>

    <!-- ============================================= -->
    <!--  Define the aspects                           -->
    <!-- ============================================= -->
    <abstract-aspect name="MyAbstractAspect">

        <advice cflow="facadeCalls" pointcut="setters AND !getters">
            <advices-ref name="log_and_cache"/>
        </advice>

        <advice pointcut="persistentFields">
            <advice-ref name="persistent"/>
        </advice>
    </aspect>

    <aspect name="MyAspect" extends="MyAbstractAspect">
        <introduction class="domain.*">
            <introduction-ref name="serializable"/>
            <introduction-ref name="mixin"/>
        </introduction>

        <pointcut-def name="facadeCalls" type="cflow" pattern="* *..facade.*.*(..)"/>
        <pointcut-def name="setters" type="method" pattern="String domain.*.set*(..)"/>
        <pointcut-def name="getters" type="method" pattern="String domain.*.get*(..)"/>
        <pointcut-def name="persistentFields" type="setField" pattern="* domain.*.*">
    </aspect>
</aspectwerkz>
]]></source>
        </section>

        <section name="Startup and transformation issues">
            <p>
                <code>AspectWerkz</code> support three different ways of
                transforming your code. All of these are managed using the
                command line tool <code>aspectwerkz</code> which resides in
                the <code>ASPECTWERKZ_HOME/bin</code> directory.
            </p>
            <subsection name="The aspectwerkz command line tool">
                <p>
                    When you start up your application using the <code>aspectwerkz</code>
                    command line tool instead of using the <code>java</code>
                    command, <code>AspectWerkz</code> will intercept the normal
                    class loading mechanism and be able to transform classes
                    loaded by <b>any</b> class loader except the bootstrap class
                    loader.
                </p>
                <p>
                    The <code>aspectwerkz</code> program assumes that both the
                    <code>ASPECTWERKZ_HOME</code> and <code>JAVA_HOME</code>
                    enviromental variables are set.
                </p>
                <p>
                    The options are:
                    <ul>
                        <li>
                            Starting up an application:<br/>
                            <code>aspectwerkz [-options] &lt;mainclass&gt; [args...]</code>
                        </li><br/>
                        <li>
                            Starting up an application using an executable jar file:<br/>
                            <code>aspectwerkz [-options] -jar &lt;jarfile&gt; [args...]</code>
                            <br/>(experimental)
                        </li><br/>
                        <li>
                            Post-process all class files in a specific directory
                            (recursively):<br/>
                            <code>aspectwerkz -offline &lt;class_path&gt; &lt;definition_file&gt; &lt;weave_model_dir&gt;</code>
                            <p/>
                            The class_path option is the path to the root
                            directory of the classes you want to transform.
                            <p/>
                            The definition_file option is the path to the
                            definition file.
                            <p/>
                            The weave_model_dir option is the path to the dir
                            containing the compiled weave model.
                            <p/>
                            Note: when you then are running the application
                            (without using the <code>aspectwerkz</code> command)
                            you have to (apart from feeding it with the
                            definition) put the aspectwerkz jar along with all
                            the the dependency jars the
                            <code>ASPECTWERKZ_HOME/lib</code> directory in your
                            classpath.
                        </li><br/>
                    </ul>
                </p>
                <p>
                    Invoke the <code>aspectwerkz</code> command line tool without
                    any arguments to get a more detailed usage description.
                </p>
                <p>
                    In all three cases you a way to feed the system with your
                    definition (compiled or not). See the
                    <a href="#Loading the definition">Loading the definition</a>
                    section for a detailed description on how to do this.
                </p>
            </subsection>

<!--            <subsection name="Ant task for offline post-processing">-->
<!--                <p>-->
<!--                   For the <code>-offline</code> mode there is an-->
<!--                   <a href="http://ant.apache.org/">Ant</a> task-->
<!--                   that you can use for simplifying your build process.-->
<!--                   (It might be useful to run the-->
<!--                   <code>ASPECTWERKZ_HOME/bin/setEnv.{bat|sh}</code> script-->
<!--                   first.)-->
<!--                </p>-->
<!--                <p>-->
<!--                    In order to use the Ant task you have to first define the-->
<!--                    task and then create a target that invokes the task.-->
<!--                </p>-->
<!--                <p>-->
<!--                    <b>Example:</b>-->
<!--<source><![CDATA[-->
<!--<target name="offline" depends="init">-->
<!--    <offlineTransformation-->
<!--        aspectWerkzHome="${basedir}"-->
<!--        definitionFile="${basedir}/src/samples/samples.xml"-->
<!--        classesDir="${basedir}/target/samples-classes"-->
<!--        metaDataDir="${basedir}/_metaData"/>-->
<!--</target>-->
<!---->
<!--<taskdef name="offlineTransformation"-->
<!--    classname="org.codehaus.aspectwerkz.task.OfflineTransformationTask"-->
<!--    classpath="${aspectwerkz.classpath}"/>-->
<!--]]></source>-->
<!--                </p>-->
<!--            </subsection>-->

            <subsection name="Compile a weave model">
                 <p>
                     If you are using <code>Introductions</code> and/or runtime
                     attributes then you <b>have</b> to compile a weave model for
                     your code before executing the <code>aspectwerkz</code> tool.
                     This weave model is then read in when the system starts up.
                     You can compile the weave model with one of the meta-data
                     compilers. See the
                     <a href="#Weave model compilation">Weave model compilation</a>
                     section for a detailed description.
                 </p>
             </subsection>

        </section>

        <section name="Loading the definition">
            <p>
                The <code>AspectWerkz</code> system needs to know where it
                can find the aspect definition.
            </p>

            <p>
                You have two options depending on your needs and settings:
                <ul>
                    <li>
                        If you are using either <code>Introductions</code>
                        or runtime attributes then you have to compile
                        a weave model for your application.
                        <p/>
                        This weave model is then read in when the system starts up.
                        You can compile the weave model with one of the meta-data
                        compilers. (See the
                        <a href="#Weave model compilation">Weave model compilation</a>
                        section for a detailed description.)
                        <p/>
                        The compiler will produce a file with the weave model
                        called <code>weaveModel.ser</code> and you have two
                        options of feeding this file to the system:
                        <ul>
                            <li>
                               Specify the path to the directory containing
                               the weave model using the: <br/>
                               <code>-Daspectwerkz.metadata.dir=&lt;path_to_meta_data_dir&gt;</code>
                               command line option.
                            </li><br/>
                            <li>
                                Put the path to the directory containing
                                the weave model on the class path.
                            </li><br/>
                        </ul>
                        (When you are using the weave model you don't have to
                        care about the XML definition.)
                    </li><br/>
                    <li>
                        If you are only using <code>Advices</code> (no
                        <code>Introductions</code> and no runtime attributes)
                        then you don't have to compile a weave model for your
                        application.
                        <p/>
                        You can just feed the system with the XML definition
                        using the:<br/>
                        <code>-Daspectwerkz.definition.file=&lt;path_to_definition_file&gt;</code>
                        command line option.
                        <p/>
                        If the this option is not specified then it the
                        system will try to locate the definition as a resource
                        called <code>aspectwerkz.xml</code> on the class path.
                        <p/>
                        You can of course compile the weave model anyway
                        and feed it to the system as outlined above.
                    </li><br/>
                    (When you are using the XML definition you don't have to
                    care about the weave model.)
                </ul>
            </p>
        </section>

        <section name="Weave model compilation">
            <p>
                If you are using <code>Introductions</code> and/or runtime
                attributes then you have to compile a weave model for your
                code before running it. This weave model is then read in when the
                system starts up.
            </p>
            <p>
                There are two different compilers that you can use to compile the
                weave model:
                <ul>
                    <li>
                        <code>SourceFileMetaDataCompiler</code> - compiles from
                        the source files. (The only option if you are using
                        runtime attributes.)
                    </li><br/>
                    <li>
                        <code>ClassFileMetaDataCompiler</code> - compiles from
                        the class files or a jar file. (If you have your
                        <code>Introductions</code> already compiled.)
                    </li><br/>
                </ul>
            </p>
            <subsection name="Compile from command line">
                <p>
                    You can run both of these compilers from the command line.
                    (It might be useful to run the
                    <code>ASPECTWERKZ_HOME/bin/setEnv.{bat|sh}</code> script first.)
                </p>
                <p>
                    <ul>
                        <li>
                            <code>java [options...] org.codehaus.aspectwerkz.metadata.SourceFileMetaDataCompiler &lt;definitionFile&gt; &lt;srcDir&gt; &lt;metaDataDir&gt; &lt;uuidForWeaveModel&gt;</code>
                        </li><br/>
                        <li>
                            <code>java [options...] org.codehaus.aspectwerkz.metadata.ClassFileMetaDataCompiler &lt;definitionFile&gt; &lt;classesDirOrJarFile&gt; &lt;metaDataDir&gt; &lt;uuidForWeaveModel&gt;</code>
                        </li><br/>
                    </ul>
                    The <code>metaDataDir</code> is the directory where you want
                    the weave model to be compiled to.
                    <br/>
                    The <code>uuidForWeaveModel</code> is the UUID that you want to have
                    for your the weave model (AspectWerkz system). The UUID can be any
                    kind of string (as long as it is unique within the JVM that your
                    application will run in). This is an optional parameter, if you
                    don't specify a UUID one will be generated for you.
                </p>
            </subsection>

            <subsection name="Compile using the Ant task">
                <p>
                    Both of the compilers can also be executed using an
                    <a href="http://ant.apache.org/">Ant</a> task. (It might be
                    useful to run the
                    <code>ASPECTWERKZ_HOME/bin/setEnv.{bat|sh}</code> script first.)
                </p>
                <p>
                    In order to use the Ant task you have to first define the
                    task and then create a target that invokes the task.
                </p>
                <p>
                    <b>Examples:</b>
<source><![CDATA[
<target name="compileWeaveModel" depends="init">
    <compileWeaveModelFromSources
        definitionFile="${basedir}/src/samples/sample.xml"
        sourceDir="${basedir}/src/samples"
        metaDataDir="${basedir}/_metaData"
        uuid="test"/>
</target>

<taskdef name="compileWeaveModelFromSources"
    classname="org.codehaus.aspectwerkz.task.SourceFileMetaDataCompilerTask"
    classpath="${aspectwerkz.classpath}"/>
]]></source>

<source><![CDATA[
<target name="compileWeaveModel" depends="init">
    <compileWeaveModelFromClasses
        definitionFile="${basedir}/src/samples/sample.xml"
        repository="${basedir}/target/samples-classes"
        metaDataDir="${basedir}/_metaData"
        uuid="test"/>
</target>

<taskdef name="compileWeaveModelFromClasses"
    classname="org.codehaus.aspectwerkz.task.ClassFileMetaDataCompilerTask"
    classpath="${aspectwerkz.classpath}"/>
]]></source>
                    The <code>metaDataDir</code> is the directory where you want
                    the weave model to be compiled to.
                    <br/>
                    The <code>uuid</code> is the UUID that you want to have for your
                    the weave model (AspectWerkz system). The UUID can be any
                    kind of string (as long as it is unique within the JVM that your
                    application will run in). This is an optional parameter, if you
                    don't specify a UUID one will be generated for you.
                </p>
            </subsection>
        </section>

        <section name="Runtime attributes">
            <p>
                <code>AspectWerkz</code> supports runtime attributes.
                Runtime attributes enables you to decorate your code
                with meta-data. This meta-data can then be parsed and used during
                the transformation process. The attributes are defined using
                JavaDoc tags.
            </p>
            <p>
                At the moment you can use attributes to define advices and
                introductions as well as to reference them in your classes. You
                can also pass parameters to your advices using attributes.
            </p>
            <p>
                You compile you attributes using the
                <code>SourceFileMetaDataCompiler</code>. (See the
                <a href="#Weave model compilation">Weave model compilation</a>
                section for a detailed description on how to use the compiler.)
            </p>
            <p>
                If you are defining your whole system <b>only</b> using attributes
                (yes, it is possible) then you <b>don't</b> need the XML definition
                at all at runtime. I.e. you can skip the
                <code>-Daspectwerkz.definition.file=..</code> parameter.
            </p>
            <subsection name="Definition tags">
                <p>
                    You can then use attributes to define both your advices and
                    your introductions.
                </p>
                <p>
                    The syntax for the definition attributes are as follows:
                    <ul>
                        <li>
                            <code>@aspectwerkz.advice-def</code> - for defining an advice,
                            should be set on class level on the advice class.
                        </li><br/>
                        <li>
                            <code>@aspectwerkz.advice-param</code> - for defining a parameter
                            that should be passed to the advice, should be set
                            on class level on the advice class. (See the
                            <a href="#Passing parameters to advices">Passing parameters to advices</a>
                            section for a detailed description.)
                        </li><br/>
                        <li>
                            <code>@aspectwerkz.introduction-def</code> - for defining an
                            introduction, should be set on class level on the
                            interface of the introduction class.
                        </li><br/>
                    </ul>
                </p>
                <p>
                    After each tag you add the different definition attributes
                    for your advice and/or introduction definition.
                </p>
                <p>
                    <b>Examples</b>
                </p>
                <p>
<source><![CDATA[
/**
 * @aspectwerkz.introduction-def name=mixins/MyMixin
 *                               implementation=mixins.MyMixinImpl
 *                               deployment-model=perInstance
 *                               attribute=my_mixin
 */
public interface Mixin {..)

/**
 * @aspectwerkz.advice-def name=advices/MyAroundAdvice
 *                         deployment-model=perJVM
 *                         attribute=log
 * @aspectwerkz.advice-param advice-ref=advices/MyAroundAdvice
 *                           name=param1
 *                           value=value1
 * @aspectwerkz.advice-param advice-ref=advices/MyAroundAdvice
 *                           name=param2
 *                           value=value2
 */
public class MyAroundAdvice extends AroundAdvice {..)
]]></source>
                </p>
            </subsection>

            <subsection name="Reference tags">
                <p>
                    You can then use these attributes by decorating your source
                    code (methods and fields) with them.
                </p>
                <p>
                    The syntax for the reference attributes are as follows:
                    <ul>
                        <li>
                            <code>@aspectwerkz.introduction</code> - for specifying the
                            introductions that should be applied to the class.
                            Is defined on class level.
                        </li><br/>
                        <li>
                            <code>@aspectwerkz.advice.method</code> - for specifying the advices
                            that should be applied to the method. Is defined
                            on method level.
                        </li><br/>
                        <li>
                            <code>@aspectwerkz.advice.setfield</code> - for specifying the advices
                            that should be applied to the field at a <code>setField</code>
                            pointcut (meaning when a field is modified). Is
                            defined on field level.
                        </li><br/>
                        <li>
                            <code>@aspectwerkz.advice.getfield</code> - for specifying the advices
                            that should be applied to the field at a <code>getField</code>
                            pointcut (meaning when a field is accessed). Is
                            defined on field level.
                        </li><br/>
                        <li>
                            <code>@aspectwerkz.advice.throws</code> - for specifying the advices
                            that should be applied to the method at a <code>throws</code>
                            pointcut (meaning when an exception is thrown out of the
                            method). Is defined on method level.
                        </li><br/>
                        <li>
                            <code>@aspectwerkz.advice.callerside</code> - for specifying the
                            advices that should be applied to the caller side
                            pointcut. I.e. the point where a certain method is
                            invoked (not executed). When using this tag you also
                            have specify the pattern that it should apply to,
                            meaning the classes that should be advised. Is
                            defined on method level.
                        </li><br/>
                        <li>
                            <code>@aspectwerkz.cflow</code> - for specifying a cflow
                            pointcut.
                        </li><br/>
                    </ul>
                </p>
                <p>
                    After each tag you add the attributes that you want to decorate
                    the method/field with.
                    <br/>
                    Like this: <code>@aspectwerkz.advice.method log cache</code>
                </p>
                <p>
                    If it is a <code>@aspectwerkz.cflow</code> attribute then
                    you specify its name instead.
                    <br/>
                    Like this: <code>@aspectwerkz.cflow pointcutname</code>
                </p>
                <p>
                    <b>Example</b>
                </p>
                <p>
<source><![CDATA[
/**
 * This class will now have the Mixin with the attribute "my_mixin" applied to it.
 *
 * @aspectwerkz.introduction my_mixin
 */
public class Target {..}

/**
 * This method will now be advised by the advices with the attributes "log" and "cache"
 * (in this order).
 *
 * @aspectwerkz.advice.method log cache
 */
public Object someMethod(String arg) {..}

/**
 * All the method invocations to this method within the "examples.caching.*" package
 * are advised by the advice with the attribute "cache_counter".
 *
 * @aspectwerkz.advice.callerside pattern=examples.caching.* cache_counter
 */
 public Object someMethod() {..}

/**
 * This method will start a cflow pointcut.
 *
 * @aspectwerkz.cflow pointcutname
 */
public Object someMethod(..) {..}

/**
 * This field is now monitored by the advice with the attribute "persistent".
 *
 * @aspectwerkz.advice.setfield persistent
 */
private int m_field;
]]></source>
                </p>
            </subsection>

            <subsection name="XML definition">
                <p>
                    If you want to define your advices and introductions in the
                    XML definition but want to use them using attributes then you
                    have to add the <code>attribute</code> attribute to the
                    <code>Advice</code> and <code>Introduction</code> definitions.
                    Here is an example:<br/>
                </p>
                <p>
<source><![CDATA[
<advice-def name="logging"
            class="advices.LoggingAdvice"
            deployment-model="perJVM"
            attribute="log"/>
]]></source>
                </p>
            </subsection>

        </section>

<!--        <section name="Persistence">-->
<!--            <p>-->
<!--                <code>AspectWerkz</code> supports transparent persistence of both-->
<!--                <code>Advice</code>s and <code>Introduction</code>s. If an-->
<!--                <code>Advice</code> or <code>Introduction</code> is marked as-->
<!--                persistent, <code>AspectWerkz</code> will transparently persist-->
<!--                it when one of it's fields becomes "dirty". The persistence manager-->
<!--                implementation is pluggable, so it is possible to extend it with-->
<!--                a custom implementation (the default implementation uses-->
<!--                <a href="http://www.prevayler.com">Prevayler</a>).-->
<!--            </p>-->
<!---->
<!--            <subsection name="Definition">-->
<!--                <p>-->
<!--                    To make an <code>Introduction</code> and/or <code>Advice</code>-->
<!--                    persistable you have to mark it as persistent when defining it.-->
<!--                    This is done by adding the <code>peristent</code> attribute and-->
<!--                    setting the value to <code>true</code>.-->
<!--                </p>-->
<!---->
<!--                <p>-->
<!--                    <b>XML definition</b><br/>-->
<!--<source><![CDATA[-->
<!--<introduction ... persistent="true"/>-->
<!---->
<!--<advice ... persistent="true"/>-->
<!--]]></source>-->
<!--            </p>-->
<!--            </subsection>-->
<!---->
<!--            <subsection name="UUID">-->
<!--                <p>-->
<!--                    To be able to retrieve the correct <code>Advice</code>s and-->
<!--                    <code>Introduction</code>s for a specific instance/class the-->
<!--                    system needs a unique handle to the specific instance/class.-->
<!--                    <code>AspectWerkz</code> solves this by adding a UUID-->
<!--                    (Universal Unique Identifier) to all the target objects.-->
<!--                    This is done during the transformation process.-->
<!--                </p>-->
<!--                <p>-->
<!--                    The only thing that you have to do is to ensure that this UUID-->
<!--                    is being persisted along with the target instance/class and is-->
<!--                    read back into the instance/class (after a restart or a crash)-->
<!--                    before use. The generated UUID is of course not available at-->
<!--                    compile time but can be retrieved during runtime using the-->
<!--                    <code>aspectwerkz.Identifiable</code> interface which all target-->
<!--                    objects are transformed to implement:-->
<!--                </p>-->
<!--                <p>-->
<!--<source><![CDATA[-->
<!--String uuid = ((Identifiable)targetObject).getUuid();-->
<!--]]></source>-->
<!--                </p>-->
<!--                <p>-->
<!--                    For those who needs to   access the UUID using reflection-->
<!--                    (perhaps using some kind of mapping tool or similar), the UUID-->
<!--                    is internally stored in a private member field with the signature-->
<!--                    <code>private String ___uuid</code>.-->
<!--                </p>-->
<!--                <p>-->
<!--                    There is a possibility for you to explicitly add the UUID to-->
<!--                    your target classes. The target class has to implement the-->
<!--                    <code>aspecwerkz.Identifiable</code> interface and implements-->
<!--                    it's <code>getUuid()</code> method, then a new UUID will not be-->
<!--                    generated but the user defined will be used. You just have to-->
<!--                    make shure that the UUID is really unique throughout the system.-->
<!--                    (The <code>org.codehaus.aspectwerkz.util.UuidGenerator</code> class might-->
<!--                    come in handy here.)-->
<!--                </p>-->
<!--            </subsection>-->
<!---->
<!--            <subsection name="Prevayler">-->
<!--                <p>-->
<!--                    The default implemententation of the <code>PersistenceManager</code>-->
<!--                    uses <a href="http://www.prevayler.org">Prevayler</a> as backend.-->
<!--                </p>-->
<!--                <p>-->
<!--                    <b>Log directory</b>-->
<!--                </p>-->
<!--                <p>-->
<!--                    The default transaction log directory is-->
<!--                    <code>./txLogs</code>. To choose another one-->
<!--                    you have to specify the-->
<!--                    <code>-Daspectwerkz.persistence.txLogDir=&lt;my_log_dir&gt;</code>-->
<!--                    option when starting up the system.-->
<!--                </p>-->
<!--                <p>-->
<!--                    <b>ClockActor daemon</b>-->
<!--                </p>-->
<!--                <p>-->
<!--                    A prevalent system is totally dependent on that the "time"-->
<!--                    is in synch throughout the system. (For more information about-->
<!--                    this see the <a href="http://www.prevayler.org">Prevayler</a>-->
<!--                    home page.) To ensure that the system starts up a ClockActor-->
<!--                    daemon thread. This thread takes care of advancing the time-->
<!--                    in the system.-->
<!--                    <br/>-->
<!--                    This thread is by default turned off but if you want to run-->
<!--                    it you have to specify the-->
<!--                    <code>-Daspectwerkz.persistence.clockactor.thread=true</code>-->
<!--                    option when starting up the system.-->
<!--               </p>-->
<!--                <p>-->
<!--                    <b>Snapshot settings</b>-->
<!--                </p>-->
<!--                <p>-->
<!--                    The <code>PersistenceManager</code> starts up a thread that-->
<!--                    takes snapshots of the whole system at regular intervals.-->
<!--                    The default settings are one snapshot every night at 03:00.-->
<!--                </p>-->
<!--                <p>-->
<!--                    If you prefer not running the snapshot scheduler daemon you-->
<!--                    can specify the-->
<!--                    <code>-Daspectwerkz.persistence.snapshot.thread=false</code>-->
<!--                    option when starting up the system.-->
<!--                </p>-->
<!--            </subsection>-->
<!--        </section>-->

        <section name="Hot deployment and reconfiguration">
            <p>
                <code>AspectWerkz</code> supports hot deployment and reconfiguration
                of both <code>Advices</code> and <code>Introductions</code>.
                It can actually create, add, remove and rearrange <code>Advices</code>
                as well as replace an introduced implementation at runtime.
                The target classes does not have to be reloaded or transformed
                again.
            </p>
            <p>
                The AspectWerkz system is retrieved by invoking the
                <code>AspectWerks.getSystem(uuid)</code>. The uuid is the same UUID
                as specfied when compiling the weave model. If an auto-generated has
                been used the generated UUID can be read in the file name of the
                weave model (weaveModel_&lt;UUID&gt;.ser). If no weave model has been
                compiled (only using the XML definition) then you can retrieve the system
                by invoking <code>AspectWerkz.getDefaultSystem()</code>.
            </p>

            <subsection name="Examples">
                <p>
                    <ul>
                        <li>
                            <p>
                                For replacing an <code>Introduction</code> implementation use:
<source><![CDATA[
AspectWerkz.getSystem(uuid).getIntroduction("mixins/Mixin").swapImplementation("mixins.NewMixinImpl");
]]></source>
                                (the new implementation has to implement the same interface as
                                the previous one)
                            </p>
                        </li><br/>
                        <li>
                            <p>
                                For creating a new <code>Advice</code> use:
<source><![CDATA[
// The parameters are:
// 1. the name of advice
// 2. the class name of advice
// 3. the deployment model
// 4. an optional user defined classloader (can be null)

AspectWerkz.getSystem(uuid).createAdvice(
        "advices/NewAdvice", "advices.NewAdvice", "perInstance", myClassLoader);
]]></source>
                            </p>
                        </li><br/>
                        <li>
                            <p>
                                For removing an <code>Advice</code> from a specific pointcut use:
<source><![CDATA[
List methodPointcuts = AspectWerkz.getSystem(uuid).getAspect("MyAspect").
                getMethodPointcuts(className, methodMetaData);
for (Iterator it = methodPointcuts.iterator(); it.hasNext();) {
    MethodPointcut pointcut = (MethodPointcut)it.next();
    if (pointcut.hasAdvice("advices/NewAdvice")) {
        pointcut.removeAdvice("advices/NewAdvice");
    }
}
]]></source>
                            </p>
                        </li><br/>
                        <li>
                            <p>
                                For adding a new <code>Advice</code> to a specific pointcut use:
<source><![CDATA[
List methodPointcuts = AspectWerkz.getSystem(uuid).getAspect("MyAspect").
                getMethodPointcuts(className, methodMetaData);
for (Iterator it = methodPointcuts.iterator(); it.hasNext();) {
    MethodPointcut pointcut = (MethodPointcut)it.next();
    if (pointcut.getExpression().equals(expression)) { // check that we are at the right pointcut
        pointcut.addAdvice("advices/NewAdvice");
    }
}
]]></source>
                            </p>
                        </li><br/>
                        <li>
                            <p>
                                For changing the order of the <code>Advices</code> at a specific pointcut use:
<source><![CDATA[
List methodPointcuts = AspectWerkz.getSystem(uuid).getAspect("MyAspect").
        getMethodPointcuts(className, methodMetaData);
for (Iterator it = methodPointcuts.iterator(); it.hasNext();) {
    MethodPointcut pointcut = (MethodPointcut)it.next();
    List advices = pointcut.getAdviceIndexTuples();

    ... // change the order of the advices

    pointcut.setAdviceIndexTuples(advices);
}
]]></source>
                            </p>
                        </li><br/>
                    </ul>
                </p>
                <p>
                    All these operations are fully thread-safe.
                </p>
            </subsection>
        </section>

        <section name="Deployment models">
            <p>
                <code>AspectWerkz</code> supports four different deployment
                models, which defines the scope of the <code>Advice</code>
                or <code>Introduction</code>.
            </p>
            <p>
                The four different deployment models are:
                <ul>
                    <li>
                        <code>perJVM</code> - one sole instance per JVM.
                        Basically the same thing as a singleton class.
                    </li><br/>
                    <li>
                        <code>perClass</code> - one instance per class.
                    </li><br/>
                    <li>
                        <code>perInstance</code> - one instance per class instance.
                    </li><br/>
                    <li>
                        <code>perThread</code> - one instance per thread.
                    </li>
                </ul>
            </p>
        </section>

        <section name="Thread safety">
            <p>
                <code>AspectWerkz</code> is generally thread-safe.
            </p>
            <p>
                There is only one rare case where you have set it explicitly
                and that is when you are spawning a new thread inside an
                <code>Advice</code>. Then you have to call
                <code>joinPoint.proceedInNewThread()</code>
                instead of the normal call to <code>joinPoint.proceed()</code>.
            </p>

            <p>
                Here is an example taken from the
                <code>Asynchronous calls</code> example in the
                <a href="/examples.html#Asynchronous calls">Examples section</a>.
<source><![CDATA[
public Object execute(final JoinPoint joinPoint) throws Throwable {
    m_threadPool.execute(
            new Runnable() {
                public void run() {
                    try {
                        // this call is made in a new thread
                        joinPoint.proceedInNewThread(); // using proceedInNewThread

                    } catch (Throwable e) {
                        throw new WrappedRuntimeException(e);
                    }
                }
            }
    );
    return null;
}]]></source>
            </p>
        </section>

        <section name="Meta data">
            <p>
                Internally <code>AspectWerkz</code> makes use of instance and
                class meta-data when handling different issues. During the
                transformation process it adds capabilities for storing
                meta-data directly in the target objects. These possibilites
                could of course also be used by the user of the framework.
            </p>
            <p>
                To use the meta-data facilities you just have to cast the target
                object to the <code>aspectwerkz.MetaDataEnhanceable</code>
                interface and invoke it's <code>___hidden$addMetaData</code> and
                <code>___hidden$getMetaData</code> methods.
            </p>
            <p>
                The meta-data can be any kind of object (not just strings).
            </p>
            <p>
                <b>Example:</b><br/>
<source><![CDATA[
// key and value can be any kind of object
((MetaDataEnhanceable)targetObject).___hidden$addMetaData(someKey, someValue);

Object someValue = ((MetaDataEnhanceable)targetObject).___hidden$getMetaData(someKey);
]]></source>
            </p>
        </section>

        <section name="Multiple weave models in one JVM">
            <p>
                <code>AspectWerkz</code> supports using multiple weave model which means
                that you can have multiple <code>AspectWerkz</code> system instances
                running concurrently within the same JVM. This can be very useful in
                for example application server environments since each WAR or JAR file
                in an application server can have its own definition and its own system
                running.
            </p>
            <p>
                This feature is based on the concept that each weave model has its own
                UUID (Unique Universal Identifier), which is a string that must be unique
                throughout the whole system (JVM or cluster).
            </p>
            <p>
                When you are compiling the weave model you can choose to provide your
                own UUID (see the <a href="#Weave model compilation">Weave model compilation</a>
                section), otherwise a UUID will be generated for you. You can read the generated
                UUID in the filename of the weave model: <code>weaveModel_&lt;theUUID&gt;.ser</code>.
            </p>
            <p>
                The UUID (the generated or the custom) is needed when you need to get a reference
                to the system, for example when doing hot deploy. Then you can retrieve the
                system like this:
                <br/><code>AspectWerkz system = AspectWerkz.getSystem(uuid);</code>
            </p>
            <p>
                If you are not compiling a weave model but feeding the JVM with an XML definition
                at startup, then a default UUID will be used (<code>AspectWerkz.DEFAULT_SYSTEM</code>)
            </p>
            <p>
                Then you can retrieve a reference to the system using:
                <br/><code>AspectWerkz system = AspectWerkz.getDefaultSystem();</code>
                <br/>
                The drawback is that you can only have one single default system running.
            </p>
            <p>
                If you are using the offline transformation then it is sufficient to put the
                pre-compiled weave model somewhere on the classpath (f.e. in the WAR/JAR).
                But if you are using the online classloader interception mechanism then all
                all the weave model used must be in one single directory and this directory
                must be fed to the JVM using the <code>aspectwerkz.metadata.dir=...</code>
                option.
            </p>
        </section>

        <section name="Pluggable container implementation">
            <p>
                You have the possibility of providing your own advice or introduction
                container implementation. This can be useful if you for example would like
                to make the advices and/or introductions persistent.
            </p>
            <p>
                To create a custom container you only need to implement the
                <code>org.codehaus.aspectwerkz.advice.AdviceContainer</code> or the
                <code>org.codehaus.aspectwerkz.introduction.IntroductionContainer</code>
                interface. The custom implementation then need to be fed to the system
                using the <code>-Daspectwerkz.introduction.container.impl=...</code> or the
                <code>-Daspectwerkz.advice.container.impl=...</code> option.
            </p>
            <p>
                If you don't provide a custom implementation the default one will be used.
            </p>
            <p>
                For an example on how to create a persistent container using <code>Prevayler</code>
                as the persistence engine see code in the <code>ASPECTWERKZ_HOME/sandbox</code> dir.
            </p>
        </section>
    </body>

</document>


