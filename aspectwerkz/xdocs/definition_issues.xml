<?xml version="1.0"?>

<document>

    <properties>
        <author email="jboner at codehaus dot org">jonas bon&#233;r</author>
        <author email="alex at gnilux dot com">alexandre vasseur</author>
        <title>Definition issues</title>
    </properties>

    <body>
        <section name="Table of Contents">
            <p>
                <ol>
                    <b>General definition issues</b><br/>
                    <li>
                        <a href="#Join point selection pattern language">Join point selection pattern language</a>
                    </li>
                    <li>
                        <a href="#AOP system">AOP system</a>
                    </li>
                    <li>
                        <a href="#Deployment models">Deployment models</a>
                    </li>
                    <li>
                        <a href="#Package namespaces">Package namespaces</a>
                    </li>
                    <li>
                        <a href="#Transformation scopes">Transformation scopes</a>
                    </li>
                    <li>
                        <a href="#DTD for XML definition">DTD for XML definition</a>
                    </li>
                    <li>
                        <a href="#Custom metadata compilation">Custom metadata compilation (JSR-175 support)</a>
                    </li><br/>
                    <b>Model 1 - XML centric</b><br/>
                    <li>
                        <a href="#Model 1 - Passing parameters to advices">Passing parameters to advices</a>
                    </li>
                    <li>
                        <a href="#Model 1 - Advice stacks">Advice stacks</a>
                    </li>
                    <li>
                        <a href="#Model 1 - Example of an XML definition">Example of an XML definition</a>
                    </li>
                    <li>
                        <a href="#Model 1 - Doclets">Doclets</a>
                    </li>
                    <li>
                        <a href="#Model 1 - Doclets compilation">Doclets compilation</a>
                    </li>
                    <li>
                        <a href="#Model 1 - Join point controller">Join point controller</a>
                    </li>
<!--                    <li>-->
<!--                        <a href="#Non-reentrancy">Non-reentrancy</a>-->
<!--                    </li>-->
                    <br/><b>Model 2 - Self defined Aspects</b><br/>
                    <li>
                        <a href="#Model 2 - Aspects compilation">Aspects compilation</a>
                    </li>
                    <li>
                        <a href="#Model 2 - Passing parameters to aspects">Passing parameters to aspects</a>
                    </li>
                    <li>
                        <a href="#Model 2 - Example of an XML definition">Example of an XML definition</a>
                    </li>
                </ol>
            </p>

        </section>

        <section name="Join point selection pattern language">
            <p>
                <code>AspectWerkz</code> support a fine-grained pattern
                language for picking out join points.
            </p>

            <p>
                You can utilize two types of wildcards when constructing your
                patterns:
            </p>
             <p>
                 <ul>
                     <li>
                         <code>*</code> - which is used as a regular wildcard.
                         Matches for example only one package level or one method parameter.
                         When used to match a package name, matches <b>at least one</b> character. Else match <b>zero or more</b> character.
                     </li><br/>
                     <li>
                         <code>..</code> - matches any sequence of characters that
                         start and end with a ".", so it can be used to pick out all
                         types in any subpackage. For example <code>org.codehaus..*</code>
                         will match all classes in all subpackages starting from
                         <code>org.codehaus</code>.
                     </li>
                 </ul>
                 Note: you can only use the <code>..</code> wildcard as the
                 "last" thing specified. I.e. this is <b>not</b> possible:
                 <code>foo.bar..test.MyClass</code>, but this is:
                 <code>foo.bar..</code>. The same thing holds for method
                 parameters.
             </p>

            <subsection name="Combining the patterns">
                <p>
                    The patterns normally consists of a combination of a class and a method
                    pattern or a class and a field pattern.
                </p>
                <p>
                    Example of a full method pattern:<br/>
                    <code>&lt;return_type_pattern&gt; &lt;package_and_class_pattern&gt;.&lt;method_name_pattern&gt;(&lt;parameter_type_patterns&gt;)</code>
                </p>
                <p>
                    Example of a full field pattern:<br/>
                    <code>&lt;field_type_pattern&gt; &lt;package_and_class_pattern&gt;.&lt;field_name_pattern&gt;</code>
                </p>
            </subsection>

            <subsection name="Class selections">
                <p>
                    For the class selections specify the full package name of
                    the class along with some wildcards.
                </p>
                <p>
                    <b>Examples:</b>
                </p>
                <p>
                    <ul>
                        <li>
                            <code>foo.bar.*</code> - will match<br/>
                            <code>foo.bar.FooBar2</code> as well as<br/>
                            <code>foo.bar.FooBear</code>.
                        </li><br/>
                        <li>
                            <code>foo.*.FooBar</code> - will match<br/>
                            <code>foo.bar.FooBar2</code> as well as<br/>
                            <code>foo.bear.FooBar</code> but not<br/>
                            <code>foo.bear.FooBear</code>.
                        </li><br/>
                        <li>
                            <code>foo.*.FooB*</code> - will match<br/>
                            <code>foo.bar.FooBar2</code> as well as<br/>
                            <code>foo.bear.FooBear</code> as well as<br/>
                            <code>foo.bear.FooB</code>.
                        </li><br/>
                        <li>
                            <code>foo..</code> - will match<br/>
                            all classes in all packages starting with foo.
                        </li>
                    </ul>
                </p>
            </subsection>

            <subsection name="Method selections">
                <p>
                    The methods are selected by specifying a pattern that
                    consists of:
                </p>
                <p>
                    <ul>
                        <li>
                            return type
                        </li>
                        <li>
                            full name of method (including class and package)
                        </li>
                        <li>
                            parameter types
                        </li>
                    </ul>
                </p>
                <p>
                    All method patterns must follow this structure:<br/>
                    <code>&lt;return_type&gt; &lt;full_method_name&gt;(&lt;parameter_types&gt;)</code>
                </p>
                <p>
                    <b>Examples</b>
                </p>
                <p>
                    <ul>
                        <li>
                            <code>int foo.*.Bar.method()</code> - will match<br/>
                            <code>int method()</code> but not<br/>
                            <code>int method(int i)</code>.
                        </li><br/>
                        <li>
                            <code>int *.method(*)</code> - will match<br/>
                            <code>int Foo.method(int i)</code> but not<br/>
                            <code>int Foo.method()</code>.
                        </li><br/>
                        <li>
                            <code>int foo.*.*.method(*,int)</code> - will match<br/>
                            <code>int method(String s, int i)</code> as well as<br/>
                            <code>int method(int i1, int i2)</code>.
                        </li><br/>
                        <li>
                            <code>int foo.*.Bar.method(..)</code> - will match<br/>
                            <code>int method()</code> as well as<br/>
                            <code>int method(String s, int i)</code> as well as<br/>
                            <code>int method(int i, double d, String s, Object o)</code>.
                        </li><br/>
                        <li>
                            <code>int foo.*.Bar.method(int,..)</code> - will match<br/>
                            <code>int method(int)</code> as well as<br/>
                            <code>int method(int i, String s)</code> as well as<br/>
                            <code>int method(int i, double d, String s, Object o)</code>.
                        </li><br/>
                        <li>
                            <code>int foo.*.Bar.method(java.lang.*)</code> - will match<br/>
                            <code>int method(String s)</code> as well as<br/>
                            <code>int method(StringBuffer sb)</code>.
                        </li><br/>
                        <li>
                            <code>int foo.*.Bar.me*o*()</code> - will match<br/>
                            <code>int method()</code> as well as<br/>
                            <code>int metamorphosis()</code> and <code>int meo()</code> but not<br/>
                            <code>int me()</code>.
                        </li><br/>
                        <li>
                            <code>* foo.*.Bar.method()</code> - will match<br/>
                            <code>int method()</code> as well as<br/>
                            <code>java.lang.String method()</code>.
                        </li><br/>
                        <li>
                            <code>java.lang.* foo.*.Bar.method()</code> - will match<br/>
                            <code>java.lang.String Bar.method()</code> as well as<br/>
                            <code>java.lang.StringBuffer Bar.method()</code>.
                        </li>
                    </ul>
                </p>
            </subsection>

            <subsection name="Field selections">
                <p>
                    The fields are selected by specifying a pattern that
                    consists of:
                </p>
                <p>
                    <ul>
                        <li>
                            field type
                        </li>
                        <li>
                            full name of field (including class and package)
                        </li>
                    </ul>
                </p>
                <p>
                    All field patterns must follow this structure:<br/>
                    <code>&lt;field_type&gt; &lt;full_field_name&gt;</code>
                </p>
                <p>
                    <b>Examples</b>
                </p>
                <p>
                    <ul>
                        <li>
                            <code>int foo.*.Bar.m_foo</code> - will match<br/>
                            <code>int m_foo</code> but not<br/>
                            <code>int s_foo</code> or<br/>
                            <code>long m_foo</code>.
                        </li><br/>
                        <li>
                            <code>* foo.*.Bar.m_foo</code> - will match<br/>
                            <code>int m_foo</code> as well as<br/>
                            <code>java.lang.String m_foo</code>.
                        </li><br/>
                        <li>
                            <code>java.lang.* foo.*.Bar.m_foo</code> - will match<br/>
                            <code>java.lang.String m_foo</code> as well as<br/>
                            <code>java.lang.StringBuffer m_foo</code>.
                        </li><br/>
                        <li>
                            <code>int foo.*.Bar.m_*</code> - will match<br/>
                            <code>int m_foo</code> as well as<br/>
                            <code>int m_bar</code>.
                        </li><br/>
                        <li>
                            <code>int foo.*.Bar.m_*oo*</code> - will match<br/>
                            <code>int m_foo</code> as well as<br/>
                            <code>int m_looser</code> as well as<br/>
                            <code>int m_oo</code>.
                        </li>
                    </ul>
                </p>

            </subsection>

            <subsection name="Subtype patterns">
                <p>
                    It is possible to pick out all subtypes of a type with the "+" wildcard.
                    The "+" wildcard follows immediately a type name pattern. So, while
                </p>
                <p>
                    <code>* foo.Bar.*(..)</code>
                </p>
                <p>
                    picks out all method call join points where an instance of exactly type Foo is
                    constructed,
                </p>
                <p>
                    <code>* foo.Bar+.*(..)</code>
                </p>
                <p>
                    picks out all method call join points where an instance of any subtype of
                    Foo (including Foo itself) is constructed.
                </p>
            </subsection>

            <subsection name="Array type patterns">
                <p>
                    A type name pattern or subtype pattern can be followed by one or more sets of
                    square brackets to make array type patterns. So Object[] is an array type
                    pattern, and so is foo.bar.*[][].
                </p>
            </subsection>

            <subsection name="Abbreviations">
                <p>
                    When picking out the return and parameter types it is
                    possible to use predefined abbreviations for the classes
                    in the <code>java.lang.*</code> and <code>java.util.*</code>
                    packages. If you specify only the class name it will be
                    mapped to the full class name for the class (you cannot use patterns in abbreviations).
                </p>
                <p>
                    <b>Examples</b>
                </p>
                <p>
                    You can use:
                    <ul>
                        <li>
                            <code>String</code> instead of <code>java.lang.String</code>
                        </li>
                        <li>
                            <code>List</code> instead of <code>java.util.List</code>
                        </li>
                        <li>
                            but not <code>String*</code> instead of <code>java.lang.String</code> or <code>java.lang.StringBuffer</code>
                        </li>
                        <li>
                            and so on...
                        </li>
                    </ul>
                </p>
                <p>
                    Apart from these abbreviations you always have to specify
                    the fully qualified name of the class (along with the
                    wildcards).
                </p>
            </subsection>

            <subsection name="Expression">
                <p>
                    It is possible to combine patterns selection together using algebraic expressions. The following operators are supported:
                    TODO check if nospace separated is supported
                    <ul>
                        <li>AND or &amp;&amp;</li>
                        <li>OR or ||</li>
                        <li>NOT or !</li>
                        <li>parenthesis for grouping</li>
                    </ul>
                    For model 1 deployed aspects, since the expression is defined in an XML file, the operator AND is more convient (else &amp; should be escaped).
                </p>
            </subsection>
        </section>

        <section name="AOP system">
            <p>
                Aspects deployed belong to a <code>system</code>. For now AspectWerkz support only a single system in the whole JVM.
                System are named thru the XML definition file and each system should have a unique name (though for now AspectWerkz is singled system).
                The system name (<code>id</code>) is used when accessing system at runtime, f.e. to swap mixin implementation.<br/>
                System is wether of type <a href="core_concepts.html#Model 1 - XML centric">Model 1 - XML centric</a> whether of type <a href="core_concepts.html#Model 2 - Self defined Aspects">Model 2 - self defined aspects</a>. The type is guessed from the
                XML file. For a detailled documentation on each system type read the <a href="core_concepts.html">core concepts</a>.
            </p>
            <p>
                Sample for a Model 1 - XML centric system
                <source><![CDATA[
<!DOCTYPE aspectwerkz PUBLIC
    "-//AspectWerkz//DTD//EN"
    "http://aspectwerkz.codehaus.org/dtd/aspectwerkz.dtd">
<aspectwerkz>
    <system id="system name">
        ...
        <aspect name="MyAspect">
            ...
        </aspect>
    </system>
</aspectwerkz>
                ]]></source>
            </p>
            <p>
                Sample for a Model 2 - Self defined aspects system
                <source><![CDATA[
<!DOCTYPE aspectwerkz PUBLIC
    "-//AspectWerkz//DTD//EN"
    "http://aspectwerkz.codehaus.org/dtd/aspectwerkz.dtd">
<aspectwerkz>
    <system id="system name">
        ...
        <use-aspect class="MySelfDefinedAspect"/>
        ...
    </system>
</aspectwerkz>
                ]]></source>
            </p>
            <p>
                Sample to access a system at runtime
                <source><![CDATA[
    SystemLoader.getSystem("system name")
                ]]></source>
            </p>
        </section>

        <section name="Deployment models">
            <p>
                <code>AspectWerkz</code> supports four different deployment
                models, which defines
                <ul>
                    <li>the scope of the <code>Advice</code> and <code>Introduction</code> in Model 1 systems</li>
                    <li>the scope of the <code>Aspect</code> and <code>Introduction</code> in Model 2 systems</li>
                </ul>
            </p>
            <p>
                The four different deployment models are:
                <ul>
                    <li>
                        <code>perJVM</code> - one sole instance per JVM.
                        Basically the same thing as a singleton class.
                    </li><br/>
                    <li>
                        <code>perClass</code> - one instance per class.
                    </li><br/>
                    <li>
                        <code>perInstance</code> - one instance per class instance.
                    </li><br/>
                    <li>
                        <code>perThread</code> - one instance per thread.
                    </li>
                </ul>
            </p>
            <p>
                The internal component model of AspectWerkz uses the <i>prototype</i> design pattern, which means for example that with a perJVM deployement
                model, 2 instances are created (one prototype and one perJVM) though only one is really used (the perJVM one).
            </p>
            <p>
                <b>In Model 2</b> since introduction implementation are inner classes, they have to follow a subset of the aspect deployment model.
                If not specified, the introduction is deployed as the aspect that defines it.
                Else the following applies:
                <table>
                    <tr>
                        <th>Introduction depl. model</th>
                        <th>required Aspect depl. model</th>
                    </tr>
                    <tr>
                        <td>perJVM</td>
                        <td>perJVM (default for Aspect)</td>
                    </tr>
                    <tr>
                        <td>perClass</td>
                        <td>perJVM or perClass</td>
                    </tr>
                    <tr>
                        <td>perInstance</td>
                        <td>perinstance or perClass or perJVM</td>
                    </tr>
                    <tr>
                        <td>perThread</td>
                        <td>perThread</td>
                    </tr>
                </table>
            </p>
        </section>

        <section name="Transformation scopes">
            <p>
                Using transformation scopes you can choose to perform the transformation within
                certain packages only. E.g. filter out all classes from all other packages in
                the transformation process. This can speed up the transformation process a lot as
                well as assure you that only classes within the packages you have defined is
                getting transformed no matter how freely you define your pointcut patterns.
            </p>
            <p>
                A transformation scope is defined using the <code>exclude</code> and <code>include</code>
                element which have one attribute <code>package</code> where you define the package
                name. You can define as many transformation scopes as you want.<br/>
                The <code>package</code> attribute supports only <code>.*</code> as an ending pattern (package and all sub package).
                TODO fix bug com.do match com.doe
                TODO check not homogenous with com.do.. - could be supported as well
            </p>

            <p>
                During the transformation process (online or offline), a class might be transformed (depending on the pointcuts) if
                <ol>
                    <li>the class does not belongs to any <code>exclude</code> packages if any</li>
                    and
                    <li>the class belongs to <b>at least one</b> <code>include</code> packages if any</li>
                </ol>
                Note that when <code>include</code> is used the selection is much more restrictive.
                This selection mechanism should be used as most as possible especially in online mode since it enables an ealry filtering.
            </p>
            <p>
                <b>Example</b>
<source><![CDATA[
<aspectwerkz>
    <system id="sample">
        <!-- Transformations will only take place within the 'org.codehaus.package' package
             and its subpackages -->
        <include package="org.codehaus"/>
        <include package="org.codehaus.*"/><!-- synonymous of org.codehaus -->
        <exclude package="com.oracle.*"/>
        ...
    </system>
</aspectwerkz>
]]></source>
            </p>
        </section>

        <section name="Package namespaces">
            <p>
                TODO fix for system level
                Package namespaces provide a way to simplify the edition of the XML definition file so that it is not necessary
                to prefix all <code>class</code> with the complete package information.<br/>
                You have two ways of defining a package namespace:
                <ul>
                    <li>
                        using the <code>base-package</code> attribute in the <code>system</code>
                        element. This defines a global package namespace for all elements defined within the <code>system</code> element.
                    </li><br/>
                    <li>
                        using the <code>package</code> element. This element has one attribute;
                        <code>name</code>, which defines the package namespace.
                    </li>
                </ul>
                The package name will be used as a prefix for all nested elements.
            </p>
            <p>
                <b>Example</b>
            </p>
            <p>
<source><![CDATA[
<aspectwerkz>
    <system id="foodemo" base-package="foo">
        <!-- All classes are prefixed by 'foo' -->

        <package name="bar">
            <!-- All classes within these 'package' tags are prefixed by 'foo.bar' -->
        </package>

        <package name="baz.buzz">
            <!-- All classes within these 'package' tags are prefixed by 'foo.baz.buzz' -->
        </package>
    </system>
</aspectwerkz>
]]></source>
            </p>
        </section>

        <section name="DTD for XML definition">
            <p>
                Each distribution comes with a bundled DTD so that it is not looked
                for on the web at runtime. The XML is not validated against its DTD at runtime so be cautious
                to provide a valid XML defintion.
            </p>
            <p>
                When you write your XML definition file, add the following at the top of your XML to reference the latest release:
                <source><![CDATA[
<!DOCTYPE aspectwerkz PUBLIC
    "-//AspectWerkz//DTD//EN"
    "http://aspectwerkz.codehaus.org/dtd/aspectwerkz.dtd">
            ]]></source>
            </p>
            <p>
                It is possible to specify a specific released version number as well (starting with 0.8)
                <source><![CDATA[
<!DOCTYPE aspectwerkz PUBLIC
    "-//AspectWerkz//DTD 0.9//EN"
    "http://aspectwerkz.codehaus.org/dtd/aspectwerkz_0_9.dtd">
                ]]></source>
            </p>
        </section>

        <section name="Custom metadata compilation">
            <p>
                Custom metadata compilation allows to turn <code>@Attribute.&lt;name&gt; [&lt;value&gt;]</code> frmo source files to <code>.class</code> files by incorporating
                them into bytecode. This can be used f.e. to implement declarative transaction demarcation for POJO.
            </p>
            <p>
                The <code>AspectC</code> utility can be used to compile custom metadata to the class bytecode.
                Custom metadata is marked with <a href="core_concepts.html#Model 2 - Metadata reference"><code>@Attribute.</code></a>.
                See AspectC <a href="#Model 2 - Aspects compilation">usage notes</a>.
            </p>
        </section>

        <section name="Model 1 - Passing parameters to advices">
            <p>
                You also have the option of passing parameters to your advices.
                This can be very convenient if you want to reuse the same
                advice but with a different configuration. To pass a parameter
                to the advice you simply add a <code>param</code> tag to the
                advice definition, like this:
            </p>
            <p>
<source><![CDATA[
<advice-def ... >
    <param name="timeout" value="10"/>
</advice-def>
]]></source>
            </p>
            <p>
                If you prefer the <code>Runtime Attributes</code> way of
                defining your advices:
            </p>
            <p>
<source><![CDATA[
/**
 * ...
 * @aspectwerkz.advice-param advice-ref=advices/MyAdvice
 *                           name=timeout
 *                           value=10
 */
 public class MyAdvice extends AroundAdvice {..}
]]></source>
            </p>
            <p>
                You can pass as many parameters to your advices as you want.
            </p>
            <p>
                At runtime you can then retrieve the parameters in your
                <code>Advice</code> like this:
<source><![CDATA[
String timeOut = getParameter("timeout");
]]></source>
            </p>
        </section>

        <section name="Model 1 - Advice stacks">
            <p>
                An <code>advice stack</code> lets you define a stack/chain with
                advices that you can refer to in your pointcuts. The order of the
                advices in the stack is the same order as they will be executed
                in.
            </p>
            <p>
                Advice stacks can come in very handy when you have a bunch of
                advices that logically belongs together and are used in the same
                order at many places in the definition. If the order between the
                advices is critical then it is recommended that you arrange the
                advices using an <code>advice stack</code>,
                (or specifying them in the same pointcut in the order you want).
            </p>
            <p>
                If the order between some advices is critical then it is
                recommended that you arrange the advices using an
                <code>advice stack</code>.
            </p>
            <p>
                <b>Example</b>
            </p>
            <p>
                You define an <code>advice stack</code> using the <code>advices</code> element:
<source><![CDATA[
<advices-def name="advicestack">
    <advice-ref name="acl"/>
    <advice-ref name="logging"/>
    <advice-ref name="caching"/>
</advices-def>
]]></source>
            </p>
            <p>
                This <code>advice stack</code> can then be referenced in your
                <code>Pointcut</code>:
<source><![CDATA[
<advice pointcut="pc1">
    <advices-ref name="advicestack"/>
</advice>
]]></source>
            </p>

        </section>

        <section name="Model 1 - Example of an XML definition">
            <p>
                Here is an example where all the definitions are put together
                into a single <code>AspectWerkz</code> XML definition file.
            </p>
<source><![CDATA[
<!DOCTYPE aspectwerkz PUBLIC
    "-//AspectWerkz//DTD//EN"
    "http://aspectwerkz.codehaus.org/dtd/aspectwerkz.dtd">

<aspectwerkz>
    <system id="example">
        <!-- ============================================= -->
        <!--  Define the advices                           -->
        <!-- ============================================= -->
        <advice-def name="log"
                    class="advices.LoggingAdvice"
                    deployment-model="perInstance"/>

        <advice-def name="cache"
                    class="advices.CachingAdvice"
                    deployment-model="perClass"/>

        <advice-def name="persistent"
                    class="advices.PersistenceAdvice"
                    deployment-model="perJVM"/>

        <advices-def name="log_and_cache">
            <advice-ref name="log"/>
            <advice-ref name="cache"/>
        </advices-def>

        <!-- ============================================= -->
        <!--  Define the introductions                     -->
        <!-- ============================================= -->
        <introduction-def name="serializable"
                          interface="java.io.Serializable"/>

        <introduction-def name="mixin"
                          interface="mixins.Mixin"
                          implementation="mixins.MixinImpl"
                          deployment-model="perInstance"/>

        <!-- ============================================= -->
        <!--  Define the aspects                           -->
        <!-- ============================================= -->
        <abstract-aspect name="MyAbstractAspect">

            <bind-advice cflow="facadeCalls" pointcut="setters AND !getters">
                <advices-ref name="log_and_cache"/>
            </bind-advice>

            <bind-advice pointcut="persistentFields">
                <advice-ref name="persistent"/>
            </bind-advice>
        </abstract-aspect>

        <aspect name="MyAspect" extends="MyAbstractAspect">
            <bind-introduction class="domain.*">
                <introduction-ref name="serializable"/>
                <introduction-ref name="mixin"/>
            </bind-introduction>

            <pointcut-def name="facadeCalls" type="cflow" pattern="* *..facade.*.*(..)"/>
            <pointcut-def name="setters" type="method" pattern="String domain.*.set*(..)"/>
            <pointcut-def name="getters" type="method" pattern="String domain.*.get*(..)"/>
            <pointcut-def name="persistentFields" type="setField" pattern="* domain.*.*"/>
        </aspect>

    </system>
</aspectwerkz>
]]></source>
        </section>

        <section name="Model 1 - Doclets">
            <p>
                <code>AspectWerkz</code> supports Doclets style instead (or in complement) of the standard Model 1 XML file.
                Doclets enables you to decorate your code
                with meta-data. This meta-data can then be parsed and turned in an XML file in a preprocessing phase.
                The Doclets attributes are defined using JavaDoc tags.
            </p>
            <p>
                At the moment you can use attributes to define advices and
                introductions as well as to reference them in your classes. You
                can also pass parameters to your advices using attributes.
            </p>
            <p>
                You transform you attributes in an XML file using the
                <code>AttributeC</code> compiler. (See the
                <a href="#Attribute compilation">Attribute compilation</a>
                section for a detailed description on how to use the compiler.)
            </p>
            <p>
                If you are defining your whole system <b>only</b> using attributes
                (yes, it is possible) then you <b>don't</b> need to write the XML definition
                at all. This one will be entirely generated.
            </p>
            <subsection name="Definition tags">
                <p>
                    You can then use attributes to define both your advices and
                    your introductions.
                </p>
                <p>
                    The syntax for the definition attributes are as follows:
                    <ul>
                        <li>
                            <code>@aspectwerkz.advice-def</code> - for defining an advice,
                            should be set on class level on the advice class.
                        </li><br/>
                        <li>
                            <code>@aspectwerkz.advice-param</code> - for defining a parameter
                            that should be passed to the advice, should be set
                            on class level on the advice class. (See the
                            <a href="#Passing parameters to advices">Passing parameters to advices</a>
                            section for a detailed description.)
                        </li><br/>
                        <li>
                            <code>@aspectwerkz.introduction-def</code> - for defining an
                            introduction, should be set on class level on the
                            interface of the introduction class.
                        </li><br/>
                    </ul>
                </p>
                <p>
                    After each tag you add the different definition attributes
                    for your advice and/or introduction definition.
                </p>
                <p>
                    <b>Examples</b>
                </p>
                <p>
<source><![CDATA[
/**
 * @aspectwerkz.introduction-def name=mixins/MyMixin
 *                               implementation=mixins.MyMixinImpl
 *                               deployment-model=perInstance
 *                               attribute=my_mixin
 */
public interface Mixin {..}

/**
 * @aspectwerkz.advice-def name=advices/MyAroundAdvice
 *                         deployment-model=perJVM
 *                         attribute=log
 * @aspectwerkz.advice-param advice-ref=advices/MyAroundAdvice
 *                           name=param1
 *                           value=value1
 * @aspectwerkz.advice-param advice-ref=advices/MyAroundAdvice
 *                           name=param2
 *                           value=value2
 */
public class MyAroundAdvice extends AroundAdvice {..}
]]></source>
                </p>
            </subsection>

            <subsection name="Reference tags">
                <p>
                    You can then use these attributes by decorating your source
                    code (methods and fields) with them.
                </p>
                <p>
                    The syntax for the reference attributes are as follows:
                    <ul>
                        <li>
                            <code>@aspectwerkz.introduction</code> - for specifying the
                            introductions that should be applied to the class.
                            Is defined on class level.
                        </li><br/>
                        <li>
                            <code>@aspectwerkz.advice.method</code> - for specifying the advices
                            that should be applied to the method. Is defined
                            on method level.
                        </li><br/>
                        <li>
                            <code>@aspectwerkz.advice.setfield</code> - for specifying the advices
                            that should be applied to the field at a <code>setField</code>
                            pointcut (meaning when a field is modified). Is
                            defined on field level.
                        </li><br/>
                        <li>
                            <code>@aspectwerkz.advice.getfield</code> - for specifying the advices
                            that should be applied to the field at a <code>getField</code>
                            pointcut (meaning when a field is accessed). Is
                            defined on field level.
                        </li><br/>
                        <li>
                            <code>@aspectwerkz.advice.throws</code> - for specifying the advices
                            that should be applied to the method at a <code>throws</code>
                            pointcut (meaning when an exception is thrown out of the
                            method). Is defined on method level.
                        </li><br/>
                        <li>
                            <code>@aspectwerkz.advice.callerside</code> - for specifying the
                            advices that should be applied to the caller side
                            pointcut. I.e. the point where a certain method is
                            invoked (not executed). When using this tag you also
                            have specify the pattern that it should apply to,
                            meaning the classes that should be advised. Is
                            defined on method level.
                        </li><br/>
                        <li>
                            <code>@aspectwerkz.cflow</code> - for specifying a cflow
                            pointcut.
                        </li><br/>
                        <li>
                            <code>@aspectwerkz.joinpoint.controller </code> - for specifying a
                            join point controller for this pointcut.
                        </li><br/>
                    </ul>
                </p>
                <p>
                    After each tag you add the attributes that you want to decorate
                    the method/field with.
                    <br/>
                    Like this: <code>@aspectwerkz.advice.method log cache</code>
                </p>
                <p>
                    If it is a <code>@aspectwerkz.cflow</code> attribute then
                    you specify its name instead.
                    <br/>
                    Like this: <code>@aspectwerkz.cflow pointcutname</code>
                </p>
                <p>
                    <b>Example</b>
                </p>
                <p>
<source><![CDATA[
/**
 * This class will now have the Mixin with the attribute "my_mixin" applied to it.
 *
 * @aspectwerkz.introduction my_mixin
 */
public class Target {..}

/**
 * This method will now be advised by the advices with the attributes "log" and "cache"
 * (in this order).
 *
 * @aspectwerkz.advice.method log cache
 */
public Object someMethod(String arg) {..}

/**
 * All the method invocations to this method within the "examples.caching.*" package
 * are advised by the advice with the attribute "cache_counter".
 *
 * @aspectwerkz.advice.callerside pattern=examples.caching.* cache_counter
 */
 public Object someMethod() {..}

/**
 * This method will start a cflow pointcut.
 *
 * @aspectwerkz.cflow pointcutname
 */
public Object someMethod(..) {..}

/**
 * This field is now monitored by the advice with the attribute "persistent".
 *
 * @aspectwerkz.advice.setfield persistent
 */
private int m_field;

/**
 * Here we define a join point controller for this join point.
 *
 * @aspectwerkz.joinpoint.controller examples.logging.MyJoinPointController
 */
public Object someMethod(..) {..}
]]></source>
                </p>
            </subsection>

            <subsection name="XML definition">
                <p>
                    If you want to define your advices and introductions in the
                    XML definition but want to use them using attributes then you
                    have to add the <code>attribute</code> attribute to the
                    <code>Advice</code> and <code>Introduction</code> definitions.
                    Here is an example:<br/>
                </p>
                <p>
<source><![CDATA[
<advice-def name="logging"
            class="advices.LoggingAdvice"
            deployment-model="perJVM"
            attribute="log"/>
]]></source>
                </p>
            </subsection>
        </section>

        <section name="Model 1 - Doclets compilation">
                <p>
                    If you are using Doclets then you have to compile them to an XML definition.
                    You can choose to compile a
                    standalone XML definition file or merge with an existing definition.
                </p>
                <p>
                    To compile the attributes you have to use the <code>AttributeC</code>
                    compiler. You can run the <code>AttributeC</code> from the command line.
                    (It might be useful to run the
                    <code>ASPECTWERKZ_HOME/bin/setEnv.{bat|sh}</code> script first.)
                </p>
                <p>
                    <code>java [options...] org.codehaus.aspectwerkz.metadata.AttributeC &lt;path to src dir&gt; &lt;file name&gt; -merge &lt;file name to merge with&gt; -uuid &lt;uuid for definition&gt;</code>
                </p>
                <p>
                    <ul>
                        <li>
                            <code>&lt;path to src dir&gt;</code> - the path to the root directory
                            for the sources
                        </li><br/>
                        <li>
                            <code>&lt;file name&gt;</code> - the name of the new XML definition
                            file to compile the attributes to
                        </li><br/>
                        <li>
                            <code>-merge &lt;file name to merge with&gt;</code> (or <code>-m</code>)
                            - the name of the file to merge the compiled attributes with.
                        </li><br/>
                        <li>
                            <code>-uuid &lt;uuid for definition&gt;</code> (or <code>-u</code>)
                            - the UUID for the definition. (Is optional and if not specified one will
                            be generated)
                        </li>
                    </ul>
                </p>

<!--            <subsection name="Compile using the Ant task">-->
<!--                TODO-->
<!--                <p>-->
<!--                    Both of the compilers can also be executed using an-->
<!--                    <a href="http://ant.apache.org/">Ant</a> task. (It might be-->
<!--                    useful to run the-->
<!--                    <code>ASPECTWERKZ_HOME/bin/setEnv.{bat|sh}</code> script first.)-->
<!--                </p>-->
<!--                <p>-->
<!--                    In order to use the Ant task you have to first define the-->
<!--                    task and then create a target that invokes the task.-->
<!--                </p>-->
<!--                <p>-->
<!--                    <b>Examples:</b>-->
<!--<source><![CDATA[-->
<!--<target name="compileWeaveModel" depends="init">-->
<!--    <compileWeaveModelFromSources-->
<!--        definitionFile="${basedir}/src/samples/sample.xml"-->
<!--        sourceDir="${basedir}/src/samples"-->
<!--        metaDataDir="${basedir}/_metaData"-->
<!--        uuid="test"/>-->
<!--</target>-->
<!---->
<!--<taskdef name="compileWeaveModelFromSources"-->
<!--    classname="org.codehaus.aspectwerkz.task.SourceFileMetaDataCompilerTask"-->
<!--    classpath="${aspectwerkz.classpath}"/>-->
<!--]]></source>-->
<!---->
<!--<source><![CDATA[-->
<!--<target name="compileWeaveModel" depends="init">-->
<!--    <compileWeaveModelFromClasses-->
<!--        definitionFile="${basedir}/src/samples/sample.xml"-->
<!--        repository="${basedir}/target/samples-classes"-->
<!--        metaDataDir="${basedir}/_metaData"-->
<!--        uuid="test"/>-->
<!--</target>-->
<!---->
<!--<taskdef name="compileWeaveModelFromClasses"-->
<!--    classname="org.codehaus.aspectwerkz.task.ClassFileMetaDataCompilerTask"-->
<!--    classpath="${aspectwerkz.classpath}"/>-->
<!--]]></source>-->
<!--                    The <code>metaDataDir</code> is the directory where you want-->
<!--                    the weave model to be compiled to.-->
<!--                    <br/>-->
<!--                    The <code>uuid</code> is the UUID that you want to have for your-->
<!--                    the weave model (AspectWerkz system). The UUID can be any-->
<!--                    kind of string (as long as it is unique within the JVM that your-->
<!--                    application will run in). This is an optional parameter, if you-->
<!--                    don't specify a UUID one will be generated for you.-->
<!--                </p>-->
<!--            </subsection>-->
        </section>

        <section name="Model 1 - Join point controller">
            <p>
                The <code>JoinPointController</code> allows you to control the execution
                flow of your advices based on custom defined constraints and rules, rules
                that can be changed at runtime.
            </p>
            <p>
                It allows you to (for example) control:
                <ul>
                    <li>
                        inter-aspect compatibility
                    </li><br/>
                    <li>
                        inter-aspect dependency
                    </li><br/>
                    <li>
                        aspect redundancy
                    </li>
                </ul>
            </p>

            <p>
                A little example of how a <code>JoinPointController</code> can be used have been
                added to the
                <a href="/examples.html#Logging + runtime attributes + parameterized advices + join point controller">logging example</a>
                in the examples section.
            </p>

            <subsection name="Implementation">
                <p>
                    To implement your own <code>JoinPointController</code> you have to implement the
                    <br/>
                    <code>org.codehaus.aspectwerkz.joinpoint.control.JoinPointController</code>
                    interface
                    <br/>
                    or extend the
                    <br/>
                    <code>org.codehaus.aspectwerkz.joinpoint.control.AbstractJoinPointController</code>
                    class.
                </p>
                <p>
                    It might be useful to take a look at the implementation for the default
                    <code>JoinPointController</code> before implementing your own.
                </p>
                <p>
                    If you let your controller implementation extend the
                    <code>org.codehaus.aspectwerkz.joinpoint.control.AbstractJoinPointController</code>
                    class then you have a bunch of convenience methods for managing advices at runtime.
                </p>

            </subsection>

            <subsection name="Definition">
                <p>
                    If you don't specify a <code>JoinPointController</code> then a default
                    <code>JoinPointController</code> (that executes the advices in the order they
                    are specified in the XML file) will be used.
                </p>
                <p>
                    <b>Attributes</b>
                </p>
                <p>
                    To specify which <code>JoinPointController</code> to use you have to use the
                    <code>@aspectwerkz.joinpoint.controller</code> tag. After this tag you specify
                    the class name of the controller you want to be used at the specific join point.
                </p>
                <p>
<source><![CDATA[
/**
 * @aspectwerkz.joinpoint.controller foo.MyJoinPointController
 */
public void someMethod() {
    ...
}
]]></source>
                </p>
                <p>
                    <b>XML definition</b>
                </p>
                <p>
                    To specify which <code>JoinPointController</code> to use you have to use the
                    <code>controller-def</code> element. This tag has two attributes that needs
                    to be specified:
                    <ul>
                        <li>
                            <code>pointcut</code> - the pointcut expression for the join points
                            that you want to have using the controller (it works fine with
                            <code>expression</code> as well).
                        </li><br/>
                        <li>
                            <code>class</code> - the class name of the join point controller.
                        </li>
                    </ul>
                </p>
                <p>
<source><![CDATA[
<aspect name="MyAspect">
    <pointcut-def name="pc1" type="method" pattern="* foo.Target.*(..)"/>

    <controller-def pointcut="pc1" class="foo.MyJoinPointController"/>
    ...
</aspect>
]]></source>
                </p>

            </subsection>
        </section>

<!--        <section name="Non-reentrancy">-->
<!--            <p>-->
<!--                By default <code>AspectWerkz</code> allows reentrancy for advices-->
<!--                at the join points. This could lead to infinite recursion, which-->
<!--                will end your application abruptly with a <code>StackOverflowException</code>.-->
<!--            </p>-->
<!--            <p>-->
<!--                To prevent this you have the option of defining some of your pointcuts as-->
<!--                <code>non-reentrant</code>, which means that the programs execution flow is-->
<!--                not allowed to enter the same join point more that once.-->
<!--            </p>-->
<!--            <subsection name="Definition">-->
<!--                <p>-->
<!--                </p>-->
<!--                <p>-->
<!--                    <b>Attributes</b>-->
<!--                </p>-->
<!--                <p>-->
<!--                    You can define the non-reentrancy in the <code>@aspectwerkz.advice.method</code>-->
<!--                    attribute tag. Simply add an attribute called <code>non-reentrant</code>-->
<!--                    and set it to <code>true</code>.-->
<!--                </p>-->
<!--                <p>-->
<!--<source><![CDATA[-->
<!--/**-->
<!-- * @aspectwerkz.advice.method log non-reentrant=true-->
<!-- */-->
<!--public void someMethod() {-->
<!--    ...-->
<!--}-->
<!--]]></source>-->
<!--                </p>-->
<!--                <p>-->
<!--                    <b>XML definition</b>-->
<!--                </p>-->
<!--                <p>-->
<!--                    To define a pointcut as <code>non-reentrant</code> in the XML definition-->
<!--                    you have to add the attribute <code>non-reentrant</code> to the-->
<!--                    <code>pointcut-def</code> element and set it to <code>true</code>.-->
<!--                </p>-->
<!--                <p>-->
<!--<source><![CDATA[-->
<!--<aspect name="MyAspect">-->
<!--    <pointcut-def ... non-reentrant="true"/>-->
<!--    ...-->
<!--</aspect>-->
<!--]]></source>-->
<!--                </p>-->
<!---->
<!--            </subsection>-->
<!--        </section>-->

        <section name="Model 2 - Aspects compilation">
            <p>
                <a href="core_concepts.html#Model 2 - Self defined Aspects">Self defined Aspects</a> need to be compiled in order to incorporate the metadata in the bytecode.
                This allows to almost totally skip the XML definition file complexity. The post compilation phase will not be needed under java 1.5 with JSR-175 support.
            </p>
            <subsection name="Aspect metadata compilation">
                <p>
                    To post-compile the aspect's <code>.class</code> files you have to use the <code>AspectC</code>
                    compiler, which needs both the regular <code>.class</code> files and the aspect sources files containing the attributes metadata.
                    You can run the <code>AspectC</code> from the command line.
                    (It might be useful to run the
                    <code>ASPECTWERKZ_HOME/bin/setEnv.{bat|sh}</code> script first.)
                </p>
                <p>
                    <code>java [options...] org.codehaus.aspectwerkz.attribdef.definition.AspectC [-verbose] &lt;path to src dir&gt; &lt;path to classes dir&gt; [&lt;path to destination dir&gt;]</code>
                </p>
                <p>
                    <ul>
                        <li>
                            <code>-verbose</code> - (optional) to activate verbose logging of compilation
                        </li>
                        <li>
                            <code>&lt;path to src dir&gt;</code> - the path directory
                            for the source files (not mandatory; it is not needed to point to the root package directory
                            since package name is extracted from the source file itself)
                        </li><br/>
                        <li>
                            <code>&lt;path to classes dir&gt;</code> - the path to the root directory of the regular <code>.class</code> files for the aspects
                        </li><br/>
                        <li>
                            <code>&lt;path to destination dir&gt;</code> - (optional)
                            - the path to the root directory to write the new <code>.class</code> files for the self-defined aspects.
                            If not specified, the initial <code>.class</code> files are overridden.
                        </li>
                    </ul>
                </p>
            </subsection>
            <subsection name="Custom metadata compilation">
                <p>
                    AspectC can also be used to handle custom metadata as described <a href="#Custom metadata compilation">here</a>.
                </p>
            </subsection>
        </section>

        <section name="Model 2 - Passing parameters to aspects">
            <p>
                You also have the option of passing parameters to your aspects.
                This can be very convenient if you want to reuse the same
                aspect but with a different configuration without using aspect inheritance.
                To pass a parameter to the aspect you simply add a <code>param</code> tag to the
                <code>use-aspect</code> definition, like this:
            </p>
            <p>
<source><![CDATA[
<use-aspect ... >
    <param name="timeout" value="10"/>
</use-aspect>
]]></source>
            </p>
            <p>
                From within an <code>Aspect</code> subclass use the method <code>___AW_getParameter("timeout")</code> to retrieve
                the parameter value as a String.
            </p>
        </section>

        <section name="Model 2 - Example of an XML definition">
            <p>
                Here is an example where all the definitions are put together
                into a single <code>AspectWerkz</code> XML definition file.
            </p>
            <source><![CDATA[
<!DOCTYPE aspectwerkz PUBLIC
    "-//AspectWerkz//DTD 0.9//EN"
    "http://aspectwerkz.codehaus.org/dtd/aspectwerkz_0_9.dtd">
<aspectwerkz>
    <system id="tests">
        <exclude package="test.attribdeff"/>
        <package name="test.attribdef.aspect">
            <use-aspect class="MemberMethodTestAspect"/>
            <use-aspect class="StaticMethodTestAspect"/>
            <use-aspect class="FieldTestAspect"/>
            <use-aspect class="CallerSideTestAspect"/>
            <use-aspect class="CFlowTestAspect"/>
            <use-aspect class="IntroductionTestAspect"/>
            <use-aspect class="DynamicDeploymentTestAspect"/>
        </package>
    </system>
</aspectwerkz>
            ]]></source>
        </section>

    </body>

</document>
