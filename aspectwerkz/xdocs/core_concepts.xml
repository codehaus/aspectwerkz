<?xml version="1.0"?>

<document>

    <properties>
        <author email="jboner at codehaus dot org">jonas bon&#233;r</author>
        <author email="alex at gnilux dot com">alexandre vasseur</author>
        <title>Core concepts</title>
    </properties>

    <body>
        <section name="Table of Contents">
            <p>
                <ol>
                    <li><a href="#Aspect models">Aspect models</a><br/></li>
                    <li><a href="#Model 1 - XML centric">Model 1 - XML centric</a>
                        <ol>
                            <li><a href="#Model 1 - Advices">Advices</a></li>
                            <li><a href="#Model 1 - Introductions">Introductions</a></li>
                            <li><a href="#Model 1 - Pointcuts">Pointcuts</a></li>
                            <li><a href="#Model 1 - Aspects">Aspects</a></li>
                            <li><a href="#Model 1 - Join points">Join points</a></li>
                        </ol>
                    </li>
                    <li><a href="#Model 2 - Self defined Aspects">Model 2 - Self defined Aspects</a>
                        <ol>
                            <li><a href="#Model 2 - Aspects">Aspects</a></li>
                            <li><a href="#Model 2 - Pointcuts">Pointcuts</a></li>
                            <li><a href="#Model 2 - Advices">Advices</a></li>
                            <li><a href="#Model 2 - Introductions">Introductions</a></li>
                            <li><a href="#Model 2 - Metadata reference">Metadata reference</a></li>
                            <li><a href="#Model 2 - Aspect post compilation">Aspect post compilation</a></li>
                        </ol>
                    </li>
                    <li><a href="#Choosing a model">Choosing a model</a></li>
                </ol>
            </p>
        </section>

        <section name="Aspect models">
            <p>
                AspectWerkz supports two models for Aspect components.
            </p>
            <p>
                The model 1 is the historical ones. Aspects are defined in an XML file as an arrangement
                of java classes which are the Advices and the Introductions implementations and interfaces.
                The Pointcuts are defined in the XML file thru a specific syntax.
                The binding between pointcuts and Advices and/or Introductions defines on which class of the application
                to apply concern brought by the Advice and Introduction implementations.
            </p>
            <p>
                The model 2 is based on MetaData (JSR-175). Aspect are pure java classes containing Advices as methods,
                Introductions as inner-class, and Pointcuts as field.
                Doclet in the Aspect class source file defines the binding between a Pointcut and Advices and/or Introductions.
                The Aspect class needs a post-compilation phase to incorporate the doclets in the aspect class file bytecode (this won't be
                needed with java 1.5).
                The XML is only declaring the Aspect classes.
            </p>
            <p>
                To understand which model to use read the next section.
            </p>
        </section>

        <section name="Model 1 - XML centric">
            <p>
                The following sections detail the Model 1 XML centric approach where Advices and Introductions are classes and
                Aspect are described in an XML file.
                <ol>
                    <li><a href="#Model 1 - Advices">Advices</a></li>
                    <li><a href="#Model 1 - Introductions">Introductions</a></li>
                    <li><a href="#Model 1 - Pointcuts">Pointcuts</a></li>
                    <li><a href="#Model 1 - Aspects">Aspects</a></li>
                    <li><a href="#Model 1 - Join points">Join points</a></li>
                </ol>
            </p>
        </section>

        <section name="Model 1 - Advices">
            <p>
                The <code>Advice</code> class implements the advice concept,
                i.e. defines code that is executed when a join point is reached.
            </p>

            <subsection name="Implementation">
                <p>
                    There are currently four types of Advices supported:
                    <ul>
                        <li>
                            <code>AroundAdvice</code> - is invoked "around" the
                            join point. Can be used to intercept method
                            invocations.
                        </li><br/>
                        <li>
                            <code>PreAdvice</code> - is invoked before the join
                            point. Can be used for advising fields or caller side
                            pointcuts.
                        </li><br/>
                        <li>
                            <code>PostAdvice</code> - is invoked after the join
                            point. Can be used for advising fields or caller side
                            pointcuts.
                        </li><br/>
                        <li>
                            <code>ThrowsAdvice</code> - advises join points
                            where an exception is thrown out of a method.
                        </li>
                    </ul>
                </p>

                <p>
                    <b>AroundAdvice</b>
                </p>
                 <p>
                    An <code>AroundAdvice</code> is implemented by extending
                    the <code>AroundAdvice</code> class and implementing the
                    abstract method <code>Object execute(final JoinPoint jp)</code>.
                </p>
                <p>
                    Please note: An <code>AroundAdvice</code> can <b>not</b> be used
                    with caller side or field pointcuts.
                </p>
                <p>
                    Here is a simple example of an <code>AroundAdvice</code>.
                    (For more examples see the
                    <a href="/examples.html">Examples section</a>.)
                    <br/>
                    It is in the method <code>execute</code> that the action
                    takes place. The <code>JoinPoint</code> object that is
                    passed to the method contains metadata of the current
                    join point. To invoke the next advice in the chain (or the
                    target method if there are no more advices) simply call
                    <code>joinPoint.proceed()</code>. This method will return
                    the result from the next advice (or the target method).
                </p>
<source><![CDATA[
public class MyAroundAdvice extends AroundAdvice {
    public MyAroundAdvice() {
        super();
    }
    public Object execute(final JoinPoint joinPoint) throws Throwable {
        // do some stuff
        Object result = joinPoint.proceed();
        // do some more stuff
        return result;
    }
}]]></source><br/>
                <p>
                    <b>PreAdvice</b>
                </p>
                <p>
                    A <code>PreAdvice</code> is implemented by extending either
                    the abstract <code>PreAdvice</code> class and implementing
                    the abstract method <code>void execute(final JoinPoint jp)</code>.
                    The <code>PreAdvice</code> class is being executed before
                    the join point (that it has been applied to) has been is reached.
                </p>
<!--                <p>-->
<!--                    A <code>PreAdvice</code> can currently <b>not</b> be used with-->
<!--                    method pointcuts.-->
<!--                </p>-->
                <p>
                    Here is a simple example of a <code>PreAdvice</code> advice.
                    It is in the method <code>execute</code> that you can implement
                    your logic. The <code>JoinPoint</code> object that is
                    passed to the method contains metadata for the current
                    join point. There is no need to call <code>joinPoint.proceed()</code>
                    for either <code>PreAdvices</code> or <code>PostAdvices</code>.
                </p>
<source><![CDATA[
public class MyPreAdvice extends PreAdvice {
    public MyPreAdvice() {
        super();
    }
    public void execute(final JoinPoint joinPoint) throws Throwable {
        // do some stuff
    }
}
]]></source><br/>
                <p>
                    <b>PostAdvice</b>
                </p>
                <p>
                    A <code>PostAdvice</code> is implemented by extending either
                    the abstract <code>PostAdvice</code> class and implementing
                    the abstract method <code>void execute(final JoinPoint jp)</code>.
                    The <code>PreAdvice</code> class is being executed before
                    the join point (that it has been applied to) has been is reached.
                </p>
<!--                <p>-->
<!--                    A <code>PostAdvice</code> can currently <b>not</b> be used with-->
<!--                    method pointcuts.-->
<!--                </p>-->
                <p>
                    Here is a simple example of a <code>PostAdvice</code> advice.
                    It is in the method <code>execute</code> that you can implement
                    your logic. The <code>JoinPoint</code> object that is
                    passed to the method contains metadata for the current
                    join point. There is no need to call <code>joinPoint.proceed()</code>
                    for either <code>PreAdvices</code> or <code>PostAdvices</code>.
                </p>
<source><![CDATA[
public class MyPostAdvice extends PostAdvice {
    public MyPostAdvice() {
        super();
    }
    public void execute(final JoinPoint joinPoint) throws Throwable {
        // do some stuff
    }
}
]]></source><br/>
                <p>
                    <b>ThrowsAdvice</b>
                </p>
                <p>
                    A <code>ThrowsAdvice</code> is implemented by extending the
                    the <code>ThrowsAdvice</code> class and implementing the abstract
                    method <code>void execute(final JoinPoint jp)</code>.
                    The <code>ThrowsAdvice</code> class is being executed
                    after the join point (that it has been applied to) has been
                    reached. I.e. when a specific exception has been thrown out
                    of a specific method.
                </p>
                <p>
                    Here is a simple example of a <code>ThrowsAdvice</code> advice.
                    It is in the method <code>execute</code> that you can implement
                    your logic. The <code>JoinPoint</code> object that is passed to
                    the method contains metadata of the current join point.
                </p>
<source><![CDATA[
public class MyThrowsAdvice extends ThrowsAdvice {
    public MyThrowsAdvice() {
        super();
    }
    public void execute(final JoinPoint joinPoint) throws Throwable {
        Throwable cause = ((ThrowsJoinPoint)joinPoint).getException());
        // do some stuff
    }
}
]]></source>
           </subsection>

            <subsection name="Definition">
                <p>
                    <b>Attributes</b>
                </p>
                <p>
                    When defining the advices there are three attributes that
                    needs to be specified:
                </p>
                <p>
                    <ul>
                        <li>
                            <code>name</code> -
                            for each advice you first have define the name of the
                            advice. This name has to be unique and will work as a handle
                            to the advice to be used when referencing the advice in the
                            system.
                        </li><br/>
                        <li>
                            <code>advice</code> -
                            secondly you have to define the class name of the advice
                            that the name attribute should be mapped to.
                        </li><br/>
                        <li>
                            <code>deployment-model</code> -
                            last we have an optional attribute specifying the deployment
                            model to use. If no deployment model is defined the default
                            perJVM (singleton) will be used.
                            (For more information about the deployment model
                            types available see the
                            <a href="/definition_issues.html#Deployment models">Deployment models section</a>).
                        </li><br/>
                    </ul>
                </p>

                <p>
                    Here you also have the possibility to pass parameters to
                    the advices. See the
                    <a href="/definition_issues.html#Passing parameters to advices">Passing parameters to advices</a>
                    section for a detailed description.
                </p>
                <p>
                    <b>XML definition</b>
                </p>
                <p>
<source><![CDATA[
<advice-def name="advices/caching"
            class="advices.CachingAdvice"
            deployment-model="perInstance">
    <param name="timeout" value="10"/>
</advice>
]]></source>
                </p>
            </subsection>
        </section>

        <section name="Model 1 - Introductions">
            <p>
                The <code>Introduction</code> class implements the concept of
                Mixins/Open Classes. I.e. an <code>Introduction</code> makes it
                possible to extend a class with a new interface and/or a new
                implementation (methods and fields).
            </p>

            <subsection name="Implementation">
                <p>
                    Both the interface and the implementation extensions are just
                    regular Java interfaces and classes. There is no need to have
                    them implement a specific interface or extend a certain class.
                    All you have to do is define them. The only rules are
                    that the introduced implementation has to implement the
                    introduced interface and have a default no-argument constructor.
                </p>
                <p>
                    When defining an interface introduction you only have to specify
                    the interface, but when introducing a new implementation to a
                    class, you must specifiy both the implementation class a
                    matching interface. This is needed since if you don't specify
                    an interface that the client can cast the target object to,
                    the introduced implementation will not be accessible.
                </p>
                <p>
                    Note: if you add more than one <code>Introduction</code> to
                    a target class then <b>you</b> have to make shure that the
                    names of the methods does not collide (or you will get
                    strange results).
                </p>
            </subsection>

            <subsection name="Definition">
                <p>
                    <b>Attributes</b>
                </p>
                <p>
                    When defining the introductions there are four attributes
                    that needs to be specified:
                </p>
                <p>
                    <ul>
                        <li>
                            <code>name</code> -
                            each introduction needs to have a unique name that will work
                            as a handle to the advice to be used when referencing the
                            introduction in the system.
                        </li><br/>
                        <li>
                            <code>interface</code> -
                            this attribute specifies the full name of the interface class
                            to use.
                        </li><br/>
                        <li>
                            <code>implementation</code> -
                            this attribute specifies the full name of the implementation
                            class to use. (Is skipped when we are defining an interface
                            introduction).
                        </li><br/>
                        <li>
                            <code>deployment-model</code> -
                            is an optional attribute specifying the deployment model
                            to use. If no deployment model is defined the default perJVM
                            (singleton) will be used. (For more information about
                            the deployment model types available see the
                            <a href="/definition_issues.html#Deployment models">Deployment models section</a>).
                        </li>
                    </ul>
                </p>

                <p>
                    <b>XML definition</b>
                </p>
                <p>
<source><![CDATA[
<introduction-def name="java/io/Serializable"
                  interface="java.io.Serializable"/>

<introduction-def name="mixins/Mixin"
                  interface="mixins.Mixin"
                  implementation="mixins.MixinImpl"
                  deployment-model="perThread"/>
]]></source>
                </p>
                <p>
                    (These examples only shows how to define the
                    <code>Introduction</code>, for examples how to add them see
                    the <a href="#Model 1 - Aspects">Aspects section</a>.)
                </p>
            </subsection>
        </section>


        <section name="Model 1 - Pointcuts">
            <p>
                The <code>Pointcut</code> class implements the pointcut concept.
                Pointcuts selects join points and values at those points,
                i.e. selects well-defined points in the program flow.
            </p>

            <subsection name="Implementation">
                <p>
                    There are currently four different types of pointcuts supported:
                    <ul>
                        <li>
                            <code>MethodPointcut</code> - picks out join points
                            defining method execution.
                            Valid advice for this pointcut is <code>AroundAdvice</code>.
                        </li><br/>
                        <li>
                            <code>FieldPointcut</code> - picks out join points
                            defining field access or modification.
                            Valid advices for this pointcut are <code>PreAdvice</code>
                            and <code>PostAdvice</code>.
                        </li><br/>
                        <li>
                            <code>ThrowsPointcut</code> - picks out join points
                            definining where an exception is thrown out of a method.
                            Valid advice for this pointcut is <code>ThrowsAdvice</code>.
                        </li><br/>
                        <li>
                            <code>CallerSidePointcut</code> - picks out join points
                            defining method invocation on the caller side.
                            Valid advices for this pointcut are <code>PreAdvice</code>
                            and <code>PostAdvice</code>.
                        </li><br/>
                        <li>
                            <code>CFlowPointcut</code> - picks out join points
                            defining a control flow (cflow). This pointcut can only
                            be used on conjunction with other pointcuts.
                        </li>
                    </ul>
                </p>
                <p>

                </p>
            </subsection>

            <subsection name="Definition">
                <p>
                    <b>Attributes</b>
                </p>
                <p>
                    When defining the pointcuts there are three attributes
                    that needs to be specified:
                </p>
                <p>
                    <ul>
                        <li>
                            <code>name</code> -
                            specifies the name of the pointcut. Needs to be a unique
                            name throughout the aspect definintion.
                            <p/>
                            Caution: names must only consist of these characters:
                            <code>[A-Z]</code>, <code>[a-z]</code>, <code>[0-9]</code>
                            and the characters <code>$</code> and <code>_</code>
                            (not for example <code>-</code> or <code>/</code>).
                        </li><br/>
                        <li>
                            <code>type</code> -
                            specifies the type of the pointcut.
                            Valid types are (all lowercase is also valid):
                            <ul>
                                <li>
                                    <code>method</code>
                                </li>
                                <li>
                                    <code>setField</code>
                                </li>
                                <li>
                                    <code>getField</code>
                                </li>
                                <li>
                                    <code>throws</code>
                                </li>
                                <li>
                                    <code>callerSide</code>
                                </li>
                                <li>
                                    <code>cflow</code>
                                </li>
                            </ul>
                        </li><br/>
                        <li>
                            <code>pattern</code> -
                            specifies the pattern for the pointcut. This is the
                            pattern that picks out the join points that should be
                            included in the pointcut.
                            <p/>
                            For the <code>ThrowsPointcut</code>
                            the pattern is defined like this:
                            <code>methodPattern#fullyQualifiedNameOfException</code>.
                            <p/>
                            For the <code>CallerSidePointcut</code>
                            the pattern is defined like this:
                            <code>callerSideClassPattern->calleeSideMethodPattern</code>.
                            <p/>
                            See the
                            <a href="/definition_issues.html#Join point selection pattern language">Join point selection pattern language</a>
                            section for a detailed description on how these
                            patterns work and are used.
`                        </li><br/>
                    </ul>
                </p>

                <p>
                    <b>XML definition</b>
                </p>
                <p>
<source><![CDATA[
<aspect ...>
    <pointcut-def name="pc1" type="method" pattern="* foo.Bar.method(..)"/>
    <pointcut-def name="pc2" type="setField" pattern="* foo.Bar.m_field"/>
    <pointcut-def name="pc3" type="getField" pattern="* foo.Bar.m_field"/>
    <pointcut-def name="pc4" type="throws" pattern="* foo.Bar.method(..)#java.lang.Exception"/>
    <pointcut-def name="pc5" type="callerSide" pattern="foo.Caller->String foo.Callee.method()"/>
    <pointcut-def name="pc6" type="cflow" pattern="* Transaction.begin(..)"/>
    ...
</aspect>
]]></source>
                </p>
            </subsection>

        </section>

        <section name="Model 1 - Aspects">
            <p>
                The <code>Aspect</code> class implements the aspect concept.
                Aspects are <code>AspectWerkz's</code> unit of modularity for
                crosscutting concerns. They are defined in terms of pointcuts,
                advices and introductions.
            </p>

            <subsection name="Definition">
                <p>
                    <b>Abstract aspects - aspect inheritance</b>
                </p>
                <p>
                    You have the possibility of defining abstract aspects that you
                    can reuse by letting aspects inherit the the abstract aspect using
                    the <code>extends</code> attribute. Aspect inheritance works
                    pretty much like regular class inheritance. An abstract aspect
                    is defined using the <code>abstract-aspect</code> element.
                </p>
                <p>
                    <b>Attributes</b>
                </p>
                <p>
                    When defining the aspects there is first one attribute
                    that needs to be specified:
                </p>
                <p>
                    <ul>
                        <li>
                            <code>name</code> - specifies a unique name for the aspect.
                        </li><br/>
                        <li>
                            <code>extends</code> - specifies the abstract aspect that
                            the aspect extends (optional).
                        </li><br/>
                   </ul>
                </p>

                <p>
                    <b>Adding the pointcuts definitions</b>
                </p>
                <p>
                    In the aspect definition you put the pointcut definitions (see the
                    <a href="#Model 1 - Pointcuts">Pointcuts section</a>).
                </p>
                <p>
                    <b>Adding the introductions</b>
                </p>
                <p>
                    Then you specify the introductions that you want to define in this
                    <code>aspect</code>. This is done using the <code>bind-introduction</code>
                    element. You can also use the <code>introduction</code> element although
                    it is deprecated and therefore not recommended.
                </p>
                <p>
                    This element has an attribute <code>class</code> where you define
                    the pattern for the classes that you want to be applied by this/these
                    introductions. Within this element you define the references to the introductions.
                    Using the <code>introduction-ref</code> element:
                    <code>&lt;introduction-ref name="nameOfIntroduction"/&gt;</code>
               </p>
                <p>
                    <b>Adding the advices</b>
                </p>
                <p>
                    You also define which advices should be applied to which pointcuts.
                    This is done using the <code>bind-advice</code> element. You can also use the
                    <code>advice</code> element although it is deprecated and therefore not recommended.
                </p>
                <p>
                    The <code>advice</code> element has an attribute called <code>expression</code>
                    (<code>pointcut</code> works fine as well) in which you can define an expression
                    based on the names of the pointcuts you have defined for this aspect.
                </p>
                <p>
                    This expression can be any (almost) kind of algebraic expression.
                    The only difference is that you have to use <code>OR</code> instead
                    of <code>||</code> and <code>AND</code> instead of <code>&amp;&amp;</code>
                    (lowercase works fine as well). AND is needed because it is cumbersome
                    to write &amp;&amp; in XML (needs to be escaped) and OR is used to make
                    it coherent;
                </p>
                <p>
                    Here you also define if the pointcut/expression should be a part of a
                    control flow using the <code>cflow</code> attribute. The <code>cflow</code>
                    is defined using its pointcut name.
                </p>
                <p>
                    <b>XML definition</b>
                </p>
                <p>
<source><![CDATA[
<abstract-aspect name="MyAbstractAspect">
    <bind-advice cflow="facadeCalls" pointcut="setters AND !getters">
        <advices-ref name="log_and_cache"/>
    </bind-advice>

    <bind-advice pointcut="persistentFields">
        <advice-ref name="persistent"/>
    </bind-advice>
</aspect>

<aspect name="MyAspect" extends="MyAbstractAspect">
    <bind-introduction class="domain.*">
        <introduction-ref name="serializable"/>
        <introduction-ref name="mixin"/>
    </bind-introduction>

    <pointcut-def name="facadeCalls" type="cflow" pattern="* *..facade.*.*(..)"/>
    <pointcut-def name="setters" type="method" pattern="String domain.*.set*(..)"/>
    <pointcut-def name="getters" type="method" pattern="String domain.*.get*(..)"/>
    <pointcut-def name="persistentFields" type="setField" pattern="* domain.*.*">
</aspect>
]]></source>
                </p>
            </subsection>
        </section>

        <section name="Model 1 - Join points">
            <p>
                The <code>JoinPoint</code> class implements the join point
                concept, i.e. a well-defined point in the program flow.
                A <code>JoinPoint</code> is picked out by a <code>Pointcut</code>.
            </p>

            <subsection name="Implementation">
                <p>
                    There are four different types of join points:
                    <ul>
                        <li>
                            <code>MethodJoinPoint</code>
                        </li><br/>
                        <li>
                            <code>FieldJoinPoint</code>
                        </li><br/>
                        <li>
                            <code>ThrowsJoinPoint</code>
                        </li><br/>
                        <li>
                            <code>CallerSideJoinPoint</code>
                        </li>
                    </ul>
                </p>

                <p>
                    You only have to deal with the different types of
                    join points when you in your <code>Advice</code> need to
                    cast the <code>JoinPoint</code> object to a specific type
                    to be able to retrieve meta-data from this specific join point.
                    See the JavaDoc for more information on what information is
                    available.
                </p>
            </subsection>
        </section>

        <section name="Model 2 - Self defined Aspects">
            <p>
                The following sections detail the Model 2 Self defined Aspects approach where Aspects are classes whose methods are Advices, fields are Pointcuts
                and Introductions are inner-classes with metadata marker (JSR-175 ready).<br/>
                You should be familiar with AOP vocabulary and AspectWerkz implementation as explained
                in the <a href="TODO">model 1</a> section.
                <ol>
                    <li><a href="#Model 2 - Aspects">Aspects</a></li>
                    <li><a href="#Model 2 - Pointcuts">Pointcuts</a></li>
                    <li><a href="#Model 2 - Advices">Advices</a></li>
                    <li><a href="#Model 2 - Introductions">Introductions</a></li>
                    <li><a href="#Model 2 - Metadata reference">Metadata reference</a></li>
                    <li><a href="#Model 2 - Aspect post compilation">Aspect compilation</a></li>
                </ol>
            </p>
        </section>

        <section name="Model 2 - Aspects">
            <p>
                The Aspect class implements the aspect concept.
                Aspects are AspectWerkz's unit of modularity for crosscutting concerns.
                They are defined in terms of pointcuts, advices and introductions.
            </p>
            <subsection name="Implementation">
                <p>
                    <b>Aspect</b>
                </p>
                <p>
                    Aspect are regular java classes. They must satisfy two criterias:
                    <ol>
                        <li>
                            extends <code>org.codehaus.aspectwerkz.attribdef.aspect.Aspect</code> whether
                            directly or indirectly by extending another subclass.
                        </li><br/>
                        <li>
                            have a <code>@Aspect</code> metadata marker at the class level ie in the class javadoc section.
                        </li>
                    </ol>
                    An aspect implementation must thus extend the <code>Aspect</code> in its object hierarchy. The <code>Aspect</code>
                    class provides usefull function to access runtime information:
                    <ul>
                        <li>
                            <code>___AW_getTargetClass()</code> to access the target class
                        </li>
                        <li>
                            See javadoc of Aspect class for a complete list
                        </li>
                    </ul>
                </p>
                <p>
                    <b>Abstract aspects - aspect inheritance</b>
                </p>
                <p>
                    Since Aspect are pure java classes in this model, you have the possibility of
                    defining abstract aspects that you can reuse by implementing another aspects
                    that inherits the abstract aspec. As regular java class you can use the <code>extends</code> keyword.
                    Aspect inheritance is exactly regular class inheritance. An abstract aspect
                    is defined using the <code>abstract</code> keyword as regular abstract class.<br/>
                </p>
                <p>
                    <b>Metadata</b>
                </p>
                <p>
                    TODO aspect doclet and extends aspect overcost.
                    When defining the aspect the deployment-model is specified as metadata argument of the metadata tag <code>@Aspect</code>.
                    The current implementation uses a doclet syntax. AspectWerkz will support JSR-175 syntax as well as soon as it is available.
                </p>
                <p>
                    <code>@Aspect</code> class level metadata has
                        <ol>
                            <li>an optional anonymous parameter which specify the deployment model. The default is perJVM if not specified.</li><br/>
                            <li>an optional <code>name=</code> named parameter which specify the name of the aspect. The default is the aspect class name if not specified.</li><br/>
                        </ol>
                    <ul>
                        <li>
                            <code>@Aspect perJVM</code> - deploys as perJVM. This is the default if only <code>@Aspect</code> is specified.
                        </li><br/>
                        <li>
                            <code>@Aspect perClass</code> - deploys as perClass.
                        </li><br/>
                        <li>
                            <code>@Aspect perInstance</code> - deploys as perInstance.
                        </li><br/>
                        <li>
                            <code>@Aspect perThread</code> - deploys as perThread.
                        </li><br/>
                   </ul>
                </p>
                <p>
                    <b>Adding the pointcuts definitions</b>
                </p>
                <p>
                    In the aspect class you put the pointcut definitions as fields of type <code>org.codehaus.aspectwerkz.attribdef.Pointcut</code>
                    with metadata to specify the type of pointcut (method, field, caller side ... ).
                    See <a href="#Model 2 - Pointcuts">Pointcuts section</a>.
                </p>

                <p>
                    <b>Adding the introductions</b>
                </p>
                <p>
                    In the aspect class you specify the introduction to add as field for pure interface introduction (marker interface with no required method)
                    or as public inner-class for interface and implementation introduction.
                </p>
                <p>
                    Pure interface introduction are added by adding a field to the aspect. The field class has to be the
                    interface that you want to introduce. The <code>@Introduce</code> metadata specify on which class pattern
                    you want the introduction to be applied.
                    See <a href="#Model 2 - Introductions">Introductions section</a>.
                </p>
                <p>
                    Interface introduction with implementation are added by adding a public inner-class to the aspect class.
                    The inner-class is then the default introduction implementation. It can extends any class you want as regular java class.
                    The <code>@Implements</code> metadata specify on which class pattern you want the introduction to be applied.
                    The interface(s) introduced can be whether set explicitly by letting the inner-class implementing the interface, wether implicitly
                    by inheritating another class which is itself implementing the interface(s).
                    This can be handy when distributing reusable aspects.
                    See <a href="#Model 2 - Introductions">Introductions section</a>.
                 </p>

                <p>
                    <b>Adding the advices</b>
                </p>
                <p>
                    In the aspect class the advice are methods conforming to the <code>public Object myMethod(final JoinPoint joinPoint) throws Throwable</code> signature.
                    A metadata allow to define the type of advice (execution, call, setFiel, getFiel, cflow) as well as the
                    method or field pattern or pattern expression to which it applies.
                    See <a href="#Model 2 - Advices">Advices section</a>
                </p>
                <p>
                    This expression can be any (almost) kind of algebraic expression.
                    The operators <code>||</code>, <code>OR</code>, <code>&amp;&amp;</code>, <code>AND</code> are supported.
                </p>
                <p>
                    Here you also define if the pointcut/expression should be a part of a
                    control flow using an algebraic <code>AND</code> expression mixing one or more
                    pointcut names with one or more poincut names of type CFlow ie whose matching <code>Pointcut</code>
                    fields are marked with <code>@CFlow</code> metadata.
                </p>
            </subsection>
            <subsection name="Definition">
                <p>
                    <b>XML definition</b>
                </p>
                <p>
                    The XML definition is just declaring which concrete aspect to use.
                    See TODO for complete reference
<source><![CDATA[
<use-aspect class="package.NotAbstractAspect"/>
]]></source>
                </p>
                <p>
                    <b>Source sample</b>
                </p>
                <p>
                    The following source sample gives the main idea of the self defined Aspect.
                    Remember metadata markers are inserted in bytecode thru a post compilation step which won't be needed under java 1.5.
                    <source><![CDATA[
/**
 * @Aspect perInstance name=SomeNameForMyAspect
 */
public class MyAspect extends Aspect {

    /**
     * @Implements com.mypackage.*
     */
    MarkerInterface anIntroduction;

    /**
     * @Execution * com.mypackage.Target.*(..)
     */
    Pointcut pc1;

    /**
     * @Around pc1
     */
    public Object advice1(final JoinPoint joinPoint) throws Throwable {
        // do some stuff
        Object result = joinPoint.proceed();
        // do some other stuff
        return result;
    }

    /**
     * @Introduce com.mypackage.Target*
     */
    public class OtherIntroduction implements ContractualInterface extends SuperMixin {
        ... // introduced methods
    }
}
]]></source>
                </p>
            </subsection>
        </section>

        <section name="Model 2 - Pointcuts">
            <p>
                The <code>Pointcut</code> class implements the pointcut concept.
                Pointcuts selects join points and values at those points,
                i.e. selects well-defined points in the program flow.
            </p>

            <subsection name="Implementation">
                <p>
                    The Pointcuts are implemented as Aspect class fields with the following requirements:
                    <ol>
                        <li>
                            the field is of type <code>org.codehaus.aspectwerkz.attribdef.Pointcut</code> in the aspect class (or hierarchy).
                        </li><br/>
                        <li>
                            metadata markers at the field level allow to define the type of Pointcut (see <a href="#Model 1 - Pointcuts">model 1 section</a>).
                        </li><br/>
                    </ol>
                </p>
                <p>
                    The name of the pointcut is the field name.<p/>
                    The following types of pointcuts are currently supported.
                    The type is specified as metadata at the field level:
                    <ul>
                        <li>
                            <code>@Custom &lt;value&gt;</code> - arbitrary custom metadata. TODO dedicated doco.
                        </li><br/>
                        <li>
                            <code>@Execution &lt;methodPattern&gt;</code> - picks out join points
                            defining method execution.
                            Valid advice method metadata for this pointcut is <code>@Around</code>
                        </li><br/>
                        <li>
                            <code>@Call &lt;callerSidePattern&gt;</code> - picks out join points
                            defining method invocation on the caller side.
                            Valid advice method metadata for this pointcut are <code>@Before</code>
                            and <code>@After</code>.
                        </li><br/>
                        <li>
                            <code>@Class ??</code> - not used. TODO check me.
                        </li><br/>
                        <li>
                            <code>@Set &lt;fieldPattern&gt;</code> - picks out join points
                            defining field modification.
                            Valid advice method metadata for this pointcut are <code>@Before</code>
                            and <code>@After</code>.
                        </li><br/>
                        <li>
                            <code>@Get &lt;fieldPattern&gt;</code> - picks out join points
                            defining field access.
                            Valid advice method metadata for this pointcut are <code>@Before</code>
                            and <code>@After</code>.
                        </li><br/>
                        <li>
                            <code>@Throws &lt;throwsPattern&gt;</code> - picks out join points
                            definining where an exception is thrown out of a method.
                            Valid advice method metadata for this pointcut is <code>@Around</code>.
                        </li><br/>
                        <li>
                            <code>@CFlow &lt;methodPattern&gt;</code> - picks out join points
                            defining a control flow (cflow). This pointcut can only
                            be used on conjunction with other pointcuts TODO types compatibility ?? in an algebraic <code>AND</code> expression.
                        </li>
                    </ul>
                </p>
                <p>
                    <source><![CDATA[
    /**
     * @Execution * com.package..*.*(..)
     */
    Poincut allMethods;

    /**
     * @Set * com.package.Constants.*
     */
    Pointcut allConstantAccess;
]]></source>
                </p>
                <p>
                    These metadata are followed by the pattern.
                    The exact syntax depends of the type of the Advice itself.
                    This is the pattern that picks out the join points that should be
                    included in the pointcut.
                    <p/>
                    For the <code>@Throws</code>
                    the pattern is defined like this:
                    <code>methodPattern#fullyQualifiedNameOfException</code>.
                    <p/>
                    For the <code>@Call</code>
                    the pattern is defined like this:
                    <code>callerSideClassPattern->calleeSideMethodPattern</code>.
                    <p/>
                    See the
                    <a href="/definition_issues.html#Join point selection pattern language">Join point selection pattern language</a>
                    section for a detailed description on how these
                    patterns work and are used.
                </p>
            </subsection>
        </section>

        <section name="Model 2 - Advices">
            <p>
                The Advices are implemented as Aspect class method with the following requirements:
                <ol>
                    <li>
                        the signature is <code>public Object myMethod(final JoinPoint joinPoint) throws Throwable</code>
                        (the public modifier is not mandatory, choose according to your needs).
                    </li><br/>
                    <li>
                        the method has a metadata that specify the advice type and the matching joinpoints thru a pointcut expression.
                        The matching joinpoints are whether defined as an anonymous pointcut (not a field)
                        whether an algebraic expression of defined poincuts, whose type matchs with the advice type.
                    </li><br/>
                </ol>
            </p>

            <subsection name="Implementation">
                <p>
                    The supported types of Advices are the following.
                    Each type is a metadata marker at the method level with:
                    <ol>
                        <li>a mandatory anonymous parameter to specify the expression for matching joinpoints.</li>
                        <li>an optional <code>name=</code> parameter which specify the advice name. Defaults to the &lt;aspect class name&gt;.&lt;method name&gt; if not specified.</li>
                    </ol>
                    <ul>
                        <li>
                            <code>@Around &lt;expression&gt;</code> - is invoked "around" the
                            join point. Can be used to intercept method
                            invocations.
                        </li><br/>
                        <li>
                            <code>@Pre &lt;expression&gt;</code> - is invoked before the join
                            point. Can be used for advising fields or caller side
                            pointcuts.
                        </li><br/>
                        <li>
                            <code>@Post &lt;expression&gt;</code> - is invoked after the join
                            point. Can be used for advising fields or caller side
                            pointcuts.
                        </li><br/>
                        <li>
                            <code>@Throws &lt;expression&gt;</code> - advises join points
                            where an exception is thrown out of a method.
                        </li>
                    </ul>
                </p>
                <p>
                    Here is a simple example of an AroundAdvice.
                    (For more examples see the
                    <a href="/examples_2.html">Examples section</a>.)
                    <br/>
                    It is in the method <code>execute</code> that the action
                    takes place. The <code>JoinPoint</code> object that is
                    passed to the method contains metadata of the current
                    join point. To invoke the next advice in the chain (or the
                    target method if there are no more advices) simply call
                    <code>joinPoint.proceed()</code>. This method will return
                    the result from the next advice (or the target method).
                    It is possible to cast the JoinPoint to the JointPoint subclass matching
                    the advice type used (<code>MethodJoinPoint</code>, <code>FieldJoinPoint</code>, <code>ThrowsJoinPoint</code> and subclasses).
                </p>
                <p>
<source><![CDATA[
    /**
     * Non anonymous expression (pc1 and pc2 are fields)
     * @Around pc1 && pc2
     */
    public Object myAroundAdvice(JoinPoint joinPoint) throws Throwable {
        // do some stuff
        Object result = joinPoint.proceed();
        // do some more stuff
        return result;
    }

    /**
     * Anonymous pointcut
     * @Around * com.package.Target.*(..)
     */
    public Object myAroundAdvice(JoinPoint joinPoint) throws Throwable {
        // do some stuff
        Object result = joinPoint.proceed();
        // do some more stuff
        return result;
    }

}]]></source>
                </p>
            </subsection>

        </section>

        <section name="Model 2 - Introductions">
            <p>
                The Introduction class implements the concept of Mixins/Open Classes.
                I.e. an Introduction makes it possible to extend a class with a new interface and/or a new implementation (methods and fields).
            </p>
            <p>
                In model 2, introductions are defined as
                <ul>
                    <li>Fields of the aspect class whose type is the interface to introduce.<br/>
                        Use if the interface does not require any implementation (marker interface).<br/>
                        Fields are marked with metadata <code>@Implements &lt;classPattern&gt;</code>.
                    </li><br/>
                    <li>Public inner class of the aspect class.<br/>
                        The inner class declares to implement the interface(s) to introduce and effectively implements it.
                        The inner class is marked with metadata <code>@Introduce &lt;classPattern&gt;</code>.
                    </li>
                </ul>
            </p>
            <subsection name="Pure Interface introduction">
                <p>
                    Interface introductions (marker interface) are defined as fields in the aspect class.
                    The type of the field is the interface to introduce.<br/>
                    The field is marked with metadata <code>@Implements &lt;classPattern&gt;</code> to specify to which classes the introduction applies.<br/>
                    The name of the introduction is the field name.TODO this is bad - aspect name concat required ?
                </p>
                <p>
                    When using abstract aspect or aspect inheritance, the aspect super class can define such introductions without
                    specifying a <code>classPattern</code> thru metadata.
                    The concrete aspect should thus override the fields to specify thru metadata to which classes the introduction applies.
                </p>
                <p>
                    <source><![CDATA[
/**
 * @Aspect
 */
public MyAspect extends Aspect {

    /** @Implements com.package.* */
    protected Serializable introduce1;

    /** @Implements com.package.* */
    public OtherMarkerInterface introduce2;

 }
                    ]]></source>
                </p>

            </subsection>
            <subsection name="Implementation introduction">
                <p>
                    TODO where is public inner class required ??? / protected etc
                    Implementation introductions (interface with concrete implementation) are defined as public inner class of the aspect class.
                    The inner class implements the interface(s) to introduce.<br/>
                    The inner class is marked with metadata <code>@Introduce &lt;classPattern&gt;</code> to specify to which classes the introduction applies.<br/>
                    The name of the introduction is the full qualified inner class name (thus like <code>&lt;aspectClassName&gt;$&lt;innerClassName&gt;</code>).
                </p>
                <p>
                    When using abstract aspect or aspect inheritance, the aspect super class can define such introductions without
                    specifying a <code>classPattern</code> thru metadata.
                    The concrete aspect should thus declare an inner class that extends the super class aspect one's and specify thru metadata to which classes the introduction applies.
                </p>
                <p>
                    <source><![CDATA[
/**
 * @Aspect
 */
public MyAspect extends Aspect {

    /** @Introduce com.package.* */
    public class MyIntroduction extends SuperIntroduction implements ToBeIntroduced {

        // introduced methods implementation
        ...
    }

 }
                    ]]></source>
                </p>

            </subsection>
            <subsection name="Implementation swapping">
                <p>
                    It is possible to replace the introduction implementation at runtime using a call like
                    <source><![CDATA[
    SystemLoader.getSystem("tests").getMixin("test.attribdef.aspect.IntroductionTestAspect$MyImpl").
        ___AW_swapImplementation("test.attribdef.aspect.IntroductionTestAspectMyImplReplacement");
                    ]]></source>
                </p>
                <p>
                    The swapped implementation must implements the introduced interfaces, but can be an autonomous class
                    or an aspect inner class. Only the default introduced implementation must be an inner class.
                </p>
            </subsection>
        </section>

        <section name="Model 2 - Metadata reference">
            <p>
                This section references all metadata used in the model 2 - Self defined aspect model.
            </p>
            <p>
                <table>
                    <tr>
                        <th>meta</th>
                        <th>level</th>
                        <th>component</th>
                        <th>anonymous parameter</th>
                        <th>parameter(s)</th>
                    </tr>
                    <tr>
                        <th colspan="5">[O:defaultValue] for optional parameter with default value</th>
                    </tr>
                    <tr>
                        <td>@Aspect</td>
                        <td>class</td>
                        <td>Aspect</td>
                        <td>perJVM | perClass | perInstance | perThread [O:perJVM]</td>
                        <td>name [0:&lt;aspectClassName&gt;]</td>
                    </tr>
                    <tr>
                        <td>@Implements</td>
                        <td>field</td>
                        <td>Interface Introduction</td>
                        <td>&lt;classPattern&gt;</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>@Introduce</td>
                        <td>inner class, class level</td>
                        <td>Implementation Introduction</td>
                        <td>&lt;classPattern&gt;</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>@Execution</td>
                        <td>Pointcut field</td>
                        <td>Pointcut, method execution</td>
                        <td>&lt;methodPattern&gt;</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>@Call</td>
                        <td>Pointcut field</td>
                        <td>Pointcut, method call</td>
                        <td>&lt;callerSidePattern&gt;</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>@Set / @Get</td>
                        <td>Pointcut field</td>
                        <td>Pointcut, field modification / access</td>
                        <td>&lt;fieldPattern&gt;</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>@Throws</td>
                        <td>Pointcut field</td>
                        <td>Pointcut, exception throwned out</td>
                        <td>&lt;throwsPattern&gt;</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>@CFlow</td>
                        <td>Pointcut field</td>
                        <td>Pointcut, in cflow of</td>
                        <td>&lt;methodPattern&gt;</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>@Around</td>
                        <td>Method</td>
                        <td>Advice for @Around, @Throws</td>
                        <td>&lt;expression&gt;</td>
                        <td>name [0:&lt;aspectClassName&gt;.&lt;methodName&gt;</td>
                    </tr>
                    <tr>
                        <td>@Pre / @Post</td>
                        <td>Method</td>
                        <td>Advice for @Call, @Set, @Get</td>
                        <td>&lt;expression&gt;</td>
                        <td>name [0:&lt;aspectClassName&gt;.&lt;methodName&gt;</td>
                    </tr>
                    <tr>
                        <td>@Throws</td>
                        <td>Method</td>
                        <td>Advice for @Throws</td>
                        <td>&lt;expression&gt;</td>
                        <td>name [0:&lt;aspectClassName&gt;.&lt;methodName&gt;</td>
                    </tr>
                    <tr>
                        <td>@Custom</td>
                        <td>any</td>
                        <td>custom runtime accessible attribute</td>
                        <td></td>
                        <td></td>
                    </tr>
                </table>
            </p>
        </section>

        <section name="Model 2 - Aspect post compilation">
            <p>
                The model 2 - self defined Aspects have to be post compiled to incorporate the metadata into the class file bybtecode.
                This post compilation will not be needed with java 1.5 and JSR-175. For now you need to first compile the aspect classes with javac compiler
                and thus post compile the <code>.class</code> files with the aspect source code as inputs.<br/>
                See <a href="definition_issues.html#Model 2 - Aspects compilation">specific part</a>
            </p>
        </section>

        <section name="Choosing a model">
            <p>
                The model 1 - XML centric allows to define the pointcuts expression in an external file. It can be thus used
                to provide aspects that needs to be tuned without extra development phase except editing an XML file.
                This model leads to a more exploded aspect since several classes are needed (one per Advice).
            </p>
            <p>
                The model 2 - Self defined aspect allows to have self contained aspect. Those are easier to maintain, but requires
                a small development phase to extend them and specify the binding as metadata.
                The self defined aspect requires and extra post compilation phase (until java 1.5).
            </p>
        </section>
    </body>

</document>
