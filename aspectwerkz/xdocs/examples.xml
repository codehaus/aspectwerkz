<?xml version="1.0"?>
<document>

    <properties>
        <title>Examples</title>
        <author email="jboner at codehaus dot org">jonas bon&#233;r</author>
    </properties>

    <body>

        <section name="Table of Contents">
            <p>
                <ol>
                    <li>
                        <a href="#Introduction">Introduction</a>
                    </li>
                    <li>
                        <a href="#Caching">Caching</a>
                    </li>
                    <li>
                        <a href="#Asynchronous calls">Asynchronous calls</a>
                    </li>
                    <li>
                        <a href="#Synchronization">Synchronization</a>
                    </li>
                    <li>
                        <a href="#Logging">Logging</a>
                    </li>
                    <li>
                        <a href="#Introductions and Mixins">Introductions and Mixins</a>
                    </li>
                    <li>
                        <a href="#Caller side pointcuts">Caller side pointcuts</a>
                    </li>
                    <li>
                        <a href="#XML definition file for the examples">XML definition file for the examples</a>
                    </li>
                    <li>
                        <a href="#Transparent persistence of POJOs">Transparent persistence of POJOs</a>
                    </li>
                </ol>
            </p>
        </section>

        <section name="Introduction">
            <p>
                Here are some simple examples to get you going. All examples
                together with ready to execute tests are to be found in the
                source distribution under <code>src/samples</code>. They are
                all defined using the same definition file;
                <code>samples.xml</code>
            </p>
            <p>
                If you are using <code>Introductions</code> and/or <code>Runtime
                Attributes</code> then you have to compile a weave model for your
                code before running it. This weave model is then read in when the
                system starts up. You can compile the weave model with one of the
                meta-data compilers. See the
                <a href="/documentation.html#Weave model compilation">Weave model compilation</a>
                section. This is done automatically in these examples.
            </p>
        </section>

        <section name="Caching">
            <p>
                This advice implements a simple caching service. It caches
                the results from the method invocations that are picked out
                by the pointcuts mapped to this advice.
            </p>
            <p>
                To run the example type: <code>maven aspectwerkz:samples:caching</code>
            </p>
<source><![CDATA[
public class CachingAdvice extends AroundAdvice {

    private Map m_cache = new StaticBucketMap(1000);

    public CachingAdvice() {
        super();
    }

    public Object execute(final JoinPoint joinPoint) throws Throwable {
        final Long hash = new Long(calculateHash((MethodJoinPoint)joinPoint));

        final Object cachedResult = m_cache.get(hash);

        // if we have a cached result; return the cache
        if (cachedResult != null) return cachedResult;

        // else, proceed with the method invocation and store the result in the cache
        final Object result = joinPoint.proceed();
        m_cache.put(hash, result);

        return result;
    }

    private long calculateHash(final MethodJoinPoint joinPoint) {
        int result = 17;
        result = 37 * result + joinPoint.getMethodName().hashCode();
        Object[] parameters = joinPoint.getParameters();
        for (int i = 0, j = parameters.length; i < j; i++) {
            result = 37 * result + parameters[i].hashCode();
        }
        return result;
    }
}]]></source>
        </section>

        <section name="Asynchronous calls">
            <p>
                This advice makes it possible to achive asynchronous method
                invocations. All the methods that are picked out by the
                pointcuts mapped to this advice are being executed in it's
                own thread. Uses a thread pool.
            </p>
            <p>
                To run the example type:
                <code>maven aspectwerkz:samples:asynchronous</code>
            </p>
<source><![CDATA[
public class AsynchronousAdvice extends AroundAdvice {

    private PooledExecutor m_threadPool = ... // initalize the thread pool

    public AsynchronousAdvice() {
        super();
    }

    public Object execute(final JoinPoint joinPoint) throws Throwable {
        m_threadPool.execute(
                new Runnable() {
                    public void run() {
                        try {
                            // invoke the intercepted method
                            joinPoint.proceedInNewThread(); // using proceedInNewThread
                        }
                        catch (Throwable e) {
                            throw new WrappedRuntimeException(e);
                        }
                    }
                }
        );
        return null;
    }
}]]></source>
        </section>

        <section name="Synchronization">
            <p>
                This advice implements method synchronization.
                It synchronizes access to the methods that are picked
                out by the pointcuts mapped to this advice.
            </p>
            <p>
                To run the example type:
                <code>maven aspectwerkz:samples:synchronization</code>
            </p>
<source><![CDATA[
public class SynchronizationAdvice extends AroundAdvice {

    private Mutex m_mutex = new Mutex();
    // if a counting semaphore is needed use:
    // private Semaphore m_mutex = new Semaphore(nrThreadsAllowed);

    public SynchronizationAdvice() {
        super();
    }

    public Object execute(final JoinPoint joinPoint) throws Throwable {
        m_mutex.acquire();
        Object result = joinPoint.proceed();
        m_mutex.release();
        return result;
    }
}]]></source>
        </section>

        <section name="Logging">
            <p>
                This advice implements a simple logging service.
                It logs the entry and exit of the methods that are picked
                out by the pointcuts mapped to this advice. In this simple
                example I am only using a small subset of all the metadata
                available from the join point.
            </p>
            <p>
                To run the example type:
                <code>maven aspectwerkz:samples:logging</code>
            </p>
<source><![CDATA[
public class LoggingAdvice extends AroundAdvice {

    private static Log s_log = ... // initialize logger

    public LoggingAdvice() {
        super();
    }

    public Object execute(final JoinPoint joinPoint) throws Throwable {
        MethodJoinPoint jp = (MethodJoinPoint)joinPoint;
        s_log.debug("--> " + jp.getTargetClass().getName() + "::" + jp.getMethodName());
        final Object result = joinPoint.proceed();
        s_log.debug("<-- " + jp.getTargetClass().getName() + "::" + jp.getMethodName());
        return result;
    }
}]]></source>
        </section>

        <section name="Introductions and Mixins">
            <p>
                This example shows both how an Mixin/Introduction is
                implemented.
            </p>
            <p>
                To run the example type:
                <code>maven aspectwerkz:samples:introduction</code><br/>
            </p>
            <p>
                <b>The Mixin/Introduction</b><br/>
                Note: if you add more than one <code>Introduction</code> to a class
                then <b>you</b> have to make shure that the names of the methods
                do not collide.
<source><![CDATA[
public interface Mixin {
    String sayHello();
}

public class MixinImpl implements Mixin {
    public String sayHello() {
        return "Hello World!";
    }
}]]></source>
                As you can see neither the interface nor the implementation class
                needs to implement a certain interface or extend a certain class.
            </p>
            <p>
                Second you have to define your <code>Introduction</code> in the
                <a href="#XML definition file for the examples">XML definition file</a>.
            </p>
             <p>
                Now you will be able to invoke your <code>Introduction</code>
                like this:
<source><![CDATA[
public class Target {
    ...
    System.out.println("The mixin says: " + ((Mixin)this).sayHello());
    ...
}]]></source>
            </p>
        </section>

        <section name="Caller side pointcuts">
            <p>
                As a part of the caching example I am also demonstrating how to
                implement caller pointcuts. Which means that the method is
                advised on the caller side and not on the callee side. I.e.
                method invocation and not method execution.
            </p>
            <p>
                To advise on the caller side your <code>Advice</code> must extend
                either the <code>PreAdvice</code> or the <code>PostAdvice</code>.
                In this example I have written a simple advice that counts the
                number of time that a certain method is invoked (not executed).
                This <code>Advice</code> extends the <code>PreAdvice</code> class
                because I want to make the count before the method is invoked
                and not after.
            </p>
            <p>
<source><![CDATA[
public class InvocationCounterAdvice extends PreAdvice {

    public InvocationCounterAdvice() {
        super();
    }

    public void execute(final JoinPoint joinPoint) throws Throwable {
        CallerSideJoinPoint jp = (CallerSideJoinPoint)joinPoint;
        CacheStatistics.addMethodInvocation(
            jp.getMethodName(), jp.getParameterTypes());
    }
}]]></source>
            </p>
            <p>
                This <code>advice</code> is then defined as usual (see the
                <a href="#XML definition file for the examples">XML definition</a>
                section), but the syntax for adding
                it to the <code>Pointcut</code> is slightly different:
            </p>
            <p>
<source><![CDATA[
<aspect ...>
    <pointcut-def name="caller"
                  type="callerSide"
                  pattern="examples.caching.*->int examples.caching.Pi.getPiDecimal(int)"/>
</aspect>
]]></source>
            </p>
            <p>
                The <code>pointcut</code> is defined by using the
                <code>callerSide</code> <code>type</code> and the pattern is the
                caller class pattern (the classes that calls the method) and the method pattern
                itself (full name including the class and package) separated by a <code>-></code>
                character.
            </p>
            <p>
                What happens now is that the <code>InvocationCounterAdvice</code>
                will be invoked before each method invocation of the
                <code>examples.caching.Pi.getPiDecimal</code> method and that
                counting will take place on the caller side.
            </p>
        </section>

        <section name="XML definition file for the examples">
            <p>
                Here is the XML definition file for the advice examples above:
            </p>
<source><![CDATA[
<?xml version="1.0"?>

<aspectwerkz>

    <!-- ============================================= -->
    <!--  Introductions                                -->
    <!-- ============================================= -->
    <introduction-def name="mixin"
                      interface="examples.introduction.Mixin"
                      implementation="examples.introduction.MixinImpl"
                      deployment-model="perJVM"/>

    <!-- ============================================= -->
    <!--  Advices                                      -->
    <!-- ============================================= -->
    <advice-def name="cache"
                advice="examples.caching.CachingAdvice"
                deployment-model="perJVM"/>

    <advice-def name="invocation_counter"
                advice="examples.caching.InvocationCounterAdvice"
                deployment-model="perJVM"/>

    <advice-def name="log"
                advice="examples.logging.LoggingAdvice"
                deployment-model="perJVM"/>

    <advice-def name="asynchronous"
                advice="examples.asynchronous.AsynchronousAdvice"
                deployment-model="perJVM"/>

    <advice-def name="synchronize"
                advice="examples.synchronization.SynchronizationAdvice"
                deployment-model="perJVM"/>

    <!-- ============================================= -->
    <!--  Aspects                                      -->
    <!-- ============================================= -->
    <aspect name="Caching">
        <pointcut-def name="callee" type="method" pattern="int examples.caching.Pi.getPiDecimal(int)"/>
        <pointcut-def name="caller" type="callerSide"
                pattern="examples.caching.*->int examples.caching.Pi.getPiDecimal(int)"/>

        <advice pointcut="callee">
            <advice-ref name="cache"/>
        </advice>
        <advice pointcut="caller">
            <advice-ref name="invocation_counter"/>
        </advice>
    </aspect>

    <aspect name="Logging">
        <pointcut-def name="logged_calls" type="method" pattern="void examples.*.Target.toLog*(..)"/>
        <advice pointcut="logged_calls">
            <advice-ref name="log"/>
        </advice>
    </aspect>

    <aspect name="Asynchronous">
        <pointcut-def name="asynchronous_calls" type="method"
                pattern="* examples.asynchronous.Target.toRunAsynchronously()"/>

        <advice pointcut="asynchronous_calls">
            <advice-ref name="asynchronous"/>
        </advice>
    </aspect>

    <abstract-aspect name="AbstractSynchronization">
        <advice pointcut="synchronized_calls">
            <advice-ref name="synchronize"/>
        </advice>
    </abstract-aspect>

    <aspect name="Synchronization" extends="AbstractSynchronization">
        <pointcut-def name="synchronized_calls" type="method"
                pattern="* examples.synchronization.Target.toSynchronize()"/>
    </aspect>

    <aspect name="Introduction">
        <introduction class="examples.introduction.Target">
            <introduction-ref name="mixin"/>
        </introduction>
    </aspect>

</aspectwerkz>
]]></source>
        </section>

        <section name="Transparent persistence of POJOs">
            <p>
                In the <code>src/samples/transparentpersistence</code> directory
                you will find an example how to implement transparent persistence
                for POJOs.
            </p>
            <p>
                Read more about it on <a href="http://blogs.codehaus.org/people/jboner/archives/000010.html">my weblog</a>.
            </p>
            <p>
                Run the example with: <code>maven aspectwerkz:samples:transparentpersistence</code>
            </p>
        </section>
    </body>

</document>

