<?xml version="1.0"?>
<document>
    <properties>
        <author email="jboner at codehaus dot org">jonas bon&#233;r</author>
        <author email="alex at gnilux dot com">Alexandre Vasseur</author>
        <title>Weaving</title>
    </properties>
    <body>
        <section name="Table of Contents">
            <p>
                <ol>
                    <li>
                        <a href="#Introduction">Introduction</a>
                    </li>
                    <li>
                        <a href="#Handling several Aspects across several deployed applications">Handling several Aspects across several deployed applications</a>
                    </li>
                    <!--                    <li>-->
                    <!--                        <a href="#Hot deployment and reconfiguration">Hot deployment and reconfiguration</a>-->
                    <!--                    </li>-->
                    <li>
                        <a href="#Offline weaving">Offline weaving (post compilation of the application)</a>
                    </li>
                    <li>
                        <a href="#Class load time weaving">Class load time weaving (online weaving, at deployment time)</a>
                    </li>
                    <li>
                        <a href="#AspectWerkz command line tool">AspectWerkz command line tool</a>
                    </li>
                    <li>
                        <a href="#Remote Proxy Server - RPC mechanism">Remote Proxy Server - RPC mechanism</a>
                    </li>
                    <!--                    <li>-->
                    <!--                        <a href="Examples">Examples</a>-->
                    <!--                        <ul>-->
                    <!--                            <li><a href="#WebLogic Server and BEA JRockit integration">WebLogic Server and BEA JRockit integration</a></li>-->
                    <!--                            <li><a href="#WebLogic Server domain wizards">WebLogic Server domain wizards</a></li>-->
                    <!--                            <li><a href="#Tomcat">Tomcat</a></li>-->
                    <!--                            <li><a href="#JBoss">JBoss</a></li>-->
                    <!--                            <li><a href="#Apache Geronimo">Apache Geronimo</a></li>-->
                    <!--                            <li><a href="ide_integration.html">IDE integration</a></li>                            -->
                    <!--                        </ul>-->
                    <!--                    </li>-->
                </ol>
            </p>
        </section>
        <section name="Introduction">
            <subsection name="Weaving Schemes">
                <p>
                    AW supports several integration schemes. Each schemes depends on your requirements and provides different advantages and drawbacks.
                    It is possible to use :
                    <ul>
                        <li>post compilation of the application (like AspectJ does): offline weaving at
                            <b>application build time</b>
                        </li>
                        <li>class load time weaving: online weaving at
                            <b>application deployment time</b>
                        </li>
                        <li>runtime weaving: online weaving in a
                            <b>running application</b> (experimental)
                        </li>
                    </ul>
                    AW distribution contains a
                    <b>command line tool</b> that helps to be up and running quickly, although it is a good thing to really
                    understand the different schemes for a production environment.
                </p>
            </subsection>
            <subsection name="Just In Time join point optimization">
                <p>
                    By default, joinpoint execution logic blocks are compiled on the fly as standalone classes.
                    This behavior is the default one since it provides the best performance, avoiding the use of reflection
                    whe it comes to executes advices and target advised method/constructor.
                    <br/>
                    If you encounter troubles with this mode, it can be for now deactivated thru the option
                    <code>-Daspectwerkz.jit.off=true</code> when you start your application (this can be used with an offline weaved
                    application as well).
                    <br/>
                    This option might be deprecated with the 1.1 version.
                </p>
            </subsection>
            <subsection name="Aspects deployment descriptors">
                <p>
                    Since release 1.0 AW support to
                    <a href="Handling several Aspects across several deployed applications"> configure several
                        <code>AspectSystem</code> alongside the deployed applications and the container
                    </a> (application server)
                    in which those are deployed. As described
                    <a href="xml_definition.html">here</a>, you need to write an
                    <b>AOP XML deployement descriptor</b> for your aspects, that declares the
                    Aspects to use, and defines or refines the pointcuts (where to do) and advices (what to do), no matter your Aspects are using an annotations based
                    definition or a full XML defintions, or both.
                    <p/>
                    When thinking about this
                    <code>aop.xml</code> file, you need to remember that the declared Aspects will affects the classes visible from the ClassLoader that can access this file.
                    For example if you package this file in
                    <code>application.war/WEB-INF/aop.xml</code>, it will affects all web-application classes, third parties libraries from
                    <code>application.war/WEB-INF/lib/</code> and all JSPs.
                    <p/>
                    If you want to affect all JVM classes, you can use the JVM option
                    <code>-Daspectwerkz.definition.file=path/aop.xml</code>, or better have one or more
                    <code>META-INF/aop.xml</code> file(s)
                    accessible from the JVM regular classpath.
                    <p/>
                    It is thus possible to organise your aspects alongside all your deployed applications, while allowing some interesting schemes: a tracing Aspect deployed
                    at the JVM level will affect all deployed applications, while Aspects deployed within the application itself will only affects this application.
                    <p/>
                    If you plan to use
                    <a href="Offline weaving">offline mode</a>, you need to post process your application as many time as you have aop.xml files, and still packaged the aop.xml file(s)
                    alongside the application and/or at a JVM wide level, depending on what you want to achieve.
                    <p/>
                    <b>To summarize, you have to remember that an
                        <code>META-INF/aop.xml</code> or
                        <code>WEB-INF/aop.xml</code> file will affect the classes loaded by the classloader(s)
                    that have this aop.xml file in their path. The JVM wide aop.xml file will affect the system classloader and all child classloaders.
                    </b>
                </p>
            </subsection>
        </section>
        <section name="Handling several Aspects across several deployed applications">
            <subsection name="Understanding class loading in Java">
                <p>
                    You should be familiar with the way Java handles
                    <b>ClassLoader isolation</b> to fully understand how to deploy your own Aspects.
                    <p/>
                    When you are invoking a
                    <code>main</code> method of a Class, this class is loaded (and lives) in the
                    <b>System ClassLoader</b>. All classes belonging to a path specified
                    with a
                    <code>-cp</code> or
                    <code>-classpath</code> JVM option will live in this ClassLoader.
                    <p/>
                    If this class is using
                    <code>java.lang.Object</code> and other
                    <code>java.*</code> classes, those have been loaded (and live) in
                    <b>Extension ClassLoader</b>
                    or
                    <b>Bootstrap ClassLoader</b>.
                    <p/>
                    The
                    <code>java.lang.Object</code> can be seen and used by your main Class since the
                    <b>System ClassLoader</b> is by convention a
                    <b>child</b> of the
                    <b>Extension ClassLoader</b>
                    which is himself a
                    <b>child</b> of the
                    <b>Boot ClassLoader</b>. This relation looks like this:
                    <code>
                        <pre>
                        Boot ClassLoader (JRE / JDK classes)
                           |
                        Extension ClassLoader (JRE extension, like SSL security etc, in jre/ext directory)
                           |
                        System ClassLoader (your main Class, and all the -cp / -classpath jars and classes)
                        </pre>
                    </code>
                    <p/>
                    When you are using an application server, there are usually many other classloaders. A simple view is to say that there is
                    one classloader per deployed application (that's why you don't need to add your war file in the JVM classpath right ?).
                    In fact the picture is a bit more complex to allow JSPs changes while the application is running etc.
                    Those
                    <b>application ClassLoaders</b> are
                    <b>child</b> of upper ClassLoaders like the
                    <b>System ClassLoader</b>, but if you deploy two war files,
                    they cannot share classes unless thoses classes are in an upper ClassLoader.
                    <p/>
                    If we deploy to war file in a Tomcat we will end-up in the following (simplified) organization:
                    <code>
                        <pre>
                        Boot ClassLoader (JRE / JDK classes)
                           |
                        Extension ClassLoader (JRE extension, like SSL security etc, in jre/ext directory)
                           |
                        System ClassLoader (the Tomcat main Class, and all the -cp / -classpath jars and classes)
                           |
                        Some Tomcat specific ClassLoader (does not really matters)
                                 |                                   |
                             First.war ClassLoader               Second.war ClassLoader
                                 |                                    |
                             WEB-INF/lib                            WEB-INF/lib
                            and WEB-INF/classes                    and WEB-INF/classes
                            ClassLoader                            ClassLoader for Second.war
                                 |   |                                 |   |   |
                            JSP ClassLoader(s)                     JSP ClassLoader(s)
                        </pre>
                    </code>
                </p>
                <p>
                    For J2EE / EJB based application, the schemes is a bit more complex but follows the same model.
                    <br/> Although this kind of organization is mainly J2EE oriented, some Swing based application are using
                    ClassLoader parent-child relation to allow for example plugin life cycles etc.
                </p>
            </subsection>
            <subsection name="Weaving scope of META-INF/aop.xml and WEB-INF/aop.xml files">
                <p>
                    The single idea you need to remember is that AW deployed Aspects thru aop.xml files have the scope of the ClassLoader
                    that has this file in its path and all its child ClassLoader(s).
                </p>
                <p>
                    Three specific paths are used:
                    <ul>
                        <li>JVM wide: defined with
                            <code>-Daspectwerkz.definition.file=path/aop.xml</code>, it impacts all JVM classes (except boot classloader for convenience). Note that it is
                            <b>not</b> mandatory to name the file aop.xml
                        </li>
                        <li>defined with
                            <code>WEB-INF/aop.xml</code>, it will impact the classes of the web application including JSPs. It is mandatory to name the file aop.xml
                        </li>
                        <li>defined with
                            <code>META-INF/aop.xml</code>, it will impact the classes that can
                            <i>see</i> this file. It is mandatory to name the file aop.xml
                        </li>
                    </ul>
                    It is thus possible to place a
                    <code>path/META-INF/aop.xml</code> in the JVM classpath (
                    <code>-cp path/;...</code>) to have the same scope as
                    the JVM wide defined one.
                    <br/>
                    If a
                    <b>jar file</b> of the JVM classpath contains a
                    <code>META-INF/aop.xml</code> file, it will aslo have the same scope.
                    <br/>
                    The
                    <b>precedence</b> between the aspects is then the one of the classpath, and then the one of the order in the
                    <code>aop.xml</code> file.
                    <p/>
                    With this model, it is thus possible to package a tracing aspect in a jar file, with a
                    <code>META-INF/aop.xml</code> file (with a pointcut for all public method execution f.e.)
                    and just add it to your classpath to allow a very simple generic tracing !
                    <br/>
                </p>
            </subsection>
            <subsection name="Aspect System">
                <p>
                    A single
                    <code>aop.xml</code> file can declare several
                    <code>Aspect Systems</code> for convenience. All will have the same weaving scope. The goal is mainly to
                    have a well organized namespace for organizing your aspects.
                    The
                    <b>precedence</b> will follow the order of the
                    <code>&lt;system&gt;</code> elements in the XML file.
                    Each system must have a unique id within a ClassLoader hierarchy, as  defined with
                    <code>&lt;system id="some/system"&gt;</code>
                    <p/>
                    In the following two systems are defined, and the
                    <code>system id</code> is using the application name and a path as a mnemonic, allthough it could
                    be any string.
                    <source><![CDATA[
        <aspectwerkz>
            <system id="First.war/WEB-INF/FirstSystem">
                <package name="examples">
                    <aspect class="caching.CachingAspect" deployment-model="perInstance"/>
                </package>
            </system>
            <system id="First.war/WEB-INF/SecondSystem">
                <aspect class="examples.trace.TracingAspect" deployment-model="perJVM"/>
            </system>
        </aspectwerkz>
                    ]]></source>
                </p>
            </subsection>
        </section>
        <section name="Offline weaving">
            <subsection name="Introduction">
                <p>
                    AW provides several way to weave the aspects in the application classes at build time. This is called
                    <i>offline weaving</i>,
                    <i>offline mode</i>, or even
                    <i>class post-processing</i>.
                    <p/>
                    With this mode you have to be sure to post-process the application classes as many times as required if you plan to use multiple Aspect Systems as described
                    <a href="#Handling several Aspects across several deployed applications">here</a>.
                    <p/>
                    There is mainly two ways to achieve this, allthough some variants can be built on top of them:
                    <ul>
                        <li>Use the AspectWerkz command line tool with the
                            <code>-offline</code> option on a specific
                            <code>.class</code> file, directory or jar file.
                        </li>
                        <li>Use the
                            <code>org.codehaus.aspectwerkz.compiler.AspectWerkzC</code> utility in an Ant or Maven script.
                        </li>
                    </ul>
                    As you might have understood, the command line tool is delegating to the
                    <code>AspectWerkzC</code> class after all required jars have been added to the classpath.
                </p>
            </subsection>
            <subsection name="Command line tool usage">
                <p>
                    The command line tool is described in a
                    <a href="#AspectWerkz command line tool">next part</a>.
                </p>
            </subsection>
            <subsection name="AspectWerkzC and Ant / Maven integration">
                <p>
                    You can find several samples of Ant and Maven integration in the AspectWerkz distribution.
                    <br/>
                    The following are the options supported by the AspectWerkzC tool. Most of them can be used as well in the
                    AW command line tool.
                    <source>
# set the classpath correctly
# see bin/setEnv in the AspectWerkz distribution

# Add Ant-1.5 in the classpath

java -cp ... org.codehaus.aspectwerkz.compiler.AspectWerkzC [-verbose] [-haltOnError] [-verify] [-cp {additional cp i}]*  {target 1} [{target i}]*

# Use -Daspectwerkz.definition.file=... option to specify the XML definition file to use
# Or rely on the META-INF/aop.xml and WEB-INF/aop.xml path lookup
                    </source>
                    <ul>
                        <li>
                            <code>-verbose</code>: turns on verbose mode (optional)
                        </li>
                        <li>
                            <code>-haltOnError</code>: stops the compilation at the first error (target2 will not be post-processed if it fails on target1) (optional)
                        </li>
                        <li>
                            <code>-verify</code>: do some bytecode verification (mainly usefull for AspectWerkz development team) (optional)
                        </li>
                        <li>
                            <code>-cp path1;path2/some.jar</code>: additional classpath needed for the compilation. Put your aspect classes in this path, and your application third parties jar if any.
                            This is mainly needed to match on subtype patterns (java.lang.String
                            <b>+</b>), where the complete classes dependancies is needed.
                            For convenience you can use several
                            <code>-cp ...</code> option. Be sure to use ";" or ":" as a path separator as for the regular JVM classpath option.
                        </li>
                        <li>
                            <code>target path/classes path/application.jar</code>: defines the classes, classes directories and jar files to post-process. It is possible to pass as many target as needed.
                        </li>
                    </ul>
                    <p/>
                    A sample for Ant using the command line tool looks like the following. You will notice that the aspect classes
                    must be in the classpath (to retrieve their annotations that defines the pointcut f.e.).
                    <p/>
                    In this sample, since the command line tool is used, it is mandatory to pass the XML definition file as the second argument.
                    <source><![CDATA[
<!-- =================================================== -->
<!--  offline transformation of the samples -->
<!-- =================================================== -->
<target name="aspectwerkz:transform"
    depends="clean, aspectwerkz:init, aspectwerkz:compile, aspectwerkz:samples:aspectc">
    <exec executable="${bin.dir}/aspectwerkz.bat">
        <arg line="-offline ${basedir}/src/application/aop.xml -verbose -verify -cp ${aspect.classes} ${application.classes}"/>
    </exec>
</target>
                    ]]></source>
                    <p/>
                    A sample for Ant using the AspectWerkzC class looks like the following:
                    <source><![CDATA[
<target name="aspectwerkz:war:transform"
    depends="aspectwerkz:compile, aspectwerkz:war:aspectc">
    <java classname="org.codehaus.aspectwerkz.compiler.AspectWerkzC" fork="true">
        <classpath refid="project.class.path"/>
        <classpath>
            <pathelement path="${build.main.dir}"/><!-- needed for abstract Aspect activation -->
            <pathelement path="${build.web.dir}"/><!-- needed for Aspect activation -->
        </classpath>
        <jvmarg value="-Daspectwerkz.definition.file=${src.web.dir}/WEB-INF/aspectwerkz.xml"/>
        <jvmarg value="-Daspectwerkz.transform.verbose=true"/><!-- an AspectWerkz weaver option -->
        <arg value="-verify"/><!-- an AspectWerkzC tool option -->
        <arg value="-verbose"/><!-- an AspectWerkzC tool option -->
        <!-- below is the classes dir to post-process. It could be some jar files as well. -->
        <arg value="${build.web.dir}"/>
        <arg value="${build.main.dir}"/>
    </java>
</target>
                    ]]></source>
                    <p/>
                    There is also a native Maven plugin for this - you can read more about it
                    <a href="TODO">here</a>.
                </p>
            </subsection>
            <subsection name="Packaging the post-compiled classes">
                <p>
                    Once the application classes (or dir / jars) have been post-compiled, those have dependancies on
                    <ul>
                        <li>AspectWerkz jars and third parties jars as described
                            <a href="TODO maven">here</a>
                        </li>
                        <li>Your own aspects classes and all aspects that might be triggered according to the
                            <code>Aspect System</code> organization
                        </li>
                    </ul>
                    It is then a good practice to package the aspects alongside your application just as regular classes, and then decide if
                    AspectWerkz jars and third parties jars should be packaged within the application (f.e. in
                    <code>First.war/WEB-INF/lib/</code>)
                    or added to the application regular classpath. You can use the
                    <code>bin/setEnv</code> script of the distribution for that, or change
                    your application startup script to add those jars in the
                    <code>-cp</code> or
                    <code>-classpath</code> JVM classpath settings.
                </p>
            </subsection>
        </section>
        <section name="Class load time weaving">
            <p>
                Class load time weaving allows to integrate AspectWerkz seamlessly in your applications, or in your whole application server.
                Several schemes are supported, for
                <b>Java 1.3, Java 1.4, Java 1.5, BEA JRockit JVM</b> etc.
                <p/>
                Allthough in some circumstances it is just a matter of adding a single JVM option and AspectWerkz jars to your classpath, a whole
                documentation is available
                <a href="online.html">here</a>.
                <br/>
                <!--                Some concrete samples are provided <a href="#Examples">in this section</a>.-->
            </p>
        </section>
        <section name="AspectWerkz command line tool">
            <subsection name="Environment setting">
                <p>
                    The command line tool is the easiest way to start using AW since it provides all classpath settings for both class load time weaving and
                    offline post-processing.
                    <p/>
                    To use it, you first need to set the
                    <code>ASPECTWERKZ_HOME</code> environment variable to the directory containing the AW installation.
                    <source>
set ASPECTWERKZ_HOME=C:\aop\aspectwerkz\

# export might be needed on Linux / Unix OS.

# The tool assumes JAVA_HOME environment variable is correctly set.
                    </source>
                    The command line tool is then in
                    <code>ASPECTWERKZ_HOME/bin</code> directory.
                    You can add this directory to your
                    <code>PATH</code> environment variable if you want.
                    <br/>
                    Type
                    <code>aspectwerkz</code> without any arguments to print the usage message.
                </p>
            </subsection>
            <subsection name="Offline compilation">
                <p>
                    To post-process all class files in a specific directory (recursively), jar or zip file:
                    <p/>
                    <code>aspectwerkz -offline &lt;definition file&gt; [-verbose] [-verify] [-haltOnError] [-cp &lt;classpath&gt;]* &lt;target classes to transform&gt;+</code>
                    <ul>
                        <li>The 'definition file' option is the path to the XML definition file (mandatory).</li>
                        <li>Turns on
                            <code>-verbose</code> to follow each step of the processing (optional).
                        </li>
                        <li>Turns on
                            <code>-verify</code> to verify all weaved class according to the Java Class Format specification (optional, mainly usefull for AW development team).
                        </li>
                        <li>When an error occurs, all classes of the current target are restored to their initilal state and
                            the processing goes on with the next target unless
                            <code>-haltOnError</code> was set (optional).
                            In this case the processing stops. Else a complete status about successfull and failed targets is printed at the end of all target processing.
                        </li>
                        <li>The 'classpath' option is the classpath needed for compilation but not to be transformed (eg
                            <code>-cp myAspects.jar;servletAPI.jar</code>). It is possible to use several
                            <code>-cp &lt;classpath&gt;</code> option instead of doing concatenation.
                        </li>
                        <li>The 'target classes to transform' option specifies the classes to transform.
                            It must the path to the root directory of the classes you want to transform, or a jar file or a zip file.
                            Several targets can be passed in one call (eg
                            <code>toTransform.jar /classes otherToTransform.jar</code>).
                        </li>
                    </ul>
                    <p/>
                    Note: when you then are running the application (without using the
                    <code>aspectwerkz</code> command)
                    you have to (apart from feeding it with the definition) put the aspectwerkz jars along with all
                    the the dependency jars the
                    <code>ASPECTWERKZ_HOME/lib</code> directory in your classpath.
                    Read more about it
                    <a href="#Packaging the post-compiled classes">here</a>.
                </p>
            </subsection>
            <subsection name="Class load time weaving">
                <p>
                    It is possible to use the command line tool as a replacement of the
                    <code>JAVA_HOME/bin/java</code> command. In such a case,
                    the command line tool will detect a suitable option for you and will enable class load time weaving.
                    <p/>
                    This is the easiest way to give a try to class load time weaving although you should read and choose the best option by yourself by reading
                    more on this topic
                    <a href="oneline.html">here</a>.
                    <p/>
                    Starting up an application (use -Daspectwerkz.definition.file=.. or have META-INF/aop.xml and WEB-INF/aop.xml files in the classpath and applications packaging as explained in this section):
                    <p/>
                    <code>aspectwerkz [-options] &lt;main class&gt; [args...]</code>
                    <p/>
                    Starting up an application using an executable jar file:
                    <p/>
                    <code>aspectwerkz [-options] -jar &lt;jar file&gt; [args...]</code>
                </p>
            </subsection>
        </section>

        <!--        <section name="Hot deployment and reconfiguration">-->
        <!--            <p>-->
        <!--                <code>AspectWerkz</code> supports hot deployment and reconfiguration-->
        <!--                of both-->
        <!--                <code>Advices</code> and-->
        <!--                <code>Introductions</code>.-->
        <!--                It can actually create, add, remove and rearrange-->
        <!--                <code>Advices</code>-->
        <!--                as well as replace an introduced implementation at runtime.-->
        <!--                The target classes does not have to be reloaded or transformed-->
        <!--                again.-->
        <!--            </p>-->
        <!--            <p>-->
        <!--                The AspectWerkz system is retrieved by invoking the-->
        <!--                <code>AspectWerks.getSystem(uuid)</code>. The uuid is the same UUID-->
        <!--                as specfied when compiling the weave model. If an auto-generated has-->
        <!--                been used the generated UUID can be read in the file name of the-->
        <!--                weave model (weaveModel_&lt;UUID&gt;.ser). If no weave model has been-->
        <!--                compiled (only using the XML definition) then you can retrieve the system-->
        <!--                by invoking-->
        <!--                <code>AspectWerkz.getDefaultSystem()</code>.-->
        <!--            </p>-->
        <!---->
        <!--            <subsection name="Examples">-->
        <!--                <p>-->
        <!--                    <ul>-->
        <!--                        <li>-->
        <!--                            For replacing an-->
        <!--                            <code>Introduction</code> implementation use:-->
        <!--                            <source><![CDATA[-->
        <!--SystemLoader.getSystem(uuid).getMixin("mixins/Mixin").-->
        <!--        ___AW_swapImplementation("mixins.NewMixinImpl");-->
        <!--                            ]]></source>-->
        <!--                            (the new implementation has to implement the same interface as-->
        <!--                            the previous one)-->
        <!--                        </li>-->
        <!--                        <br/>-->
        <!--                        <li>-->
        <!--                            For creating a new-->
        <!--                            <code>Advice</code> use:-->
        <!--                            <source><![CDATA[-->
        <!--// The parameters are:-->
        <!--// 1. the name of advice-->
        <!--// 2. the class name of advice-->
        <!--// 3. the deployment model-->
        <!--// 4. an optional user defined classloader (can be null)-->
        <!---->
        <!--((XmlDefSystem)SystemLoader.getSystem(uuid)).createAdvice(-->
        <!--        "advices/NewAdvice", "advices.NewAdvice", "perInstance", myClassLoader);-->
        <!--                            ]]></source>-->
        <!--                        </li>-->
        <!--                        <br/>-->
        <!--                        <li>-->
        <!--                            For removing an-->
        <!--                            <code>Advice</code> from a specific pointcut use:-->
        <!--                            <source><![CDATA[-->
        <!--List methodPointcuts = SystemLoader.getSystem(uuid).getAspectMetaData("MyAspect").-->
        <!--                getMethodPointcuts(className, methodMetaData);-->
        <!--for (Iterator it = methodPointcuts.iterator(); it.hasNext();) {-->
        <!--    MethodPointcut pointcut = (MethodPointcut)it.next();-->
        <!--    if (pointcut.hasAdvice("advices/NewAdvice")) {-->
        <!--        pointcut.removeAdvice("advices/NewAdvice");-->
        <!--    }-->
        <!--}-->
        <!--                            ]]></source>-->
        <!--                        </li>-->
        <!--                        <br/>-->
        <!--                        <li>-->
        <!--                            For adding a new-->
        <!--                            <code>Advice</code> to a specific pointcut use:-->
        <!--                            <source><![CDATA[-->
        <!--List methodPointcuts = SystemLoader.getSystem(uuid).getAspectMetaData("MyAspect").-->
        <!--                getMethodPointcuts(className, methodMetaData);-->
        <!--for (Iterator it = methodPointcuts.iterator(); it.hasNext();) {-->
        <!--    MethodPointcut pointcut = (MethodPointcut)it.next();-->
        <!--    if (pointcut.getExpression().equals(expression)) { // check that we are at the right pointcut-->
        <!--        pointcut.addAdvice("advices/NewAdvice");-->
        <!--    }-->
        <!--}-->
        <!--                            ]]></source>-->
        <!--                        </li>-->
        <!--                        <br/>-->
        <!--                        <li>-->
        <!--                            For changing the order of the-->
        <!--                            <code>Advices</code> at a specific pointcut use:-->
        <!--                            <source><![CDATA[-->
        <!--List methodPointcuts = SystemLoader.getSystem(uuid).getAspectMetaData("MyAspect").-->
        <!--        getMethodPointcuts(className, methodMetaData);-->
        <!--for (Iterator it = methodPointcuts.iterator(); it.hasNext();) {-->
        <!--    MethodPointcut pointcut = (MethodPointcut)it.next();-->
        <!--    List advices = pointcut.getAdviceIndexTuples();-->
        <!---->
        <!--    ... // change the order of the advices-->
        <!---->
        <!--    pointcut.setAdviceIndexTuples(advices);-->
        <!--}-->
        <!--                            ]]></source>-->
        <!--                        </li>-->
        <!--                        <br/>-->
        <!--                    </ul>-->
        <!--                </p>-->
        <!--                <p>-->
        <!--                    All these operations are fully thread-safe.-->
        <!--                </p>-->
        <!--            </subsection>-->
        <!--        </section>-->
        <section name="Remote Proxy Server - RPC mechanism">
            <p>
                <code>AspectWerkz</code> provides an RPC mechanism that allows you to use the
                instrumented objects (advices and mixins) seamlessly on a remote client site.
            </p>
            <subsection name="Client side">
                <p>
                    You can use the remote proxy on the client side in two ways:
                    <ul>
                        <li>
                            create a client proxy that creates a matching instance on the server.
                            The client now has seamless access this new specific instance on the server.
                            <p>
                                <b>Example:</b>
                                <source><![CDATA[
...
// creates a new remote proxy for the MixinImpl class which
// maps to an instance of this class on the server
RemoteProxy remoteProxy = RemoteProxy.createClientProxy(
        new String[]{"examples.connectivity.Mixin"},
        "examples.connectivity.MixinImpl",
        "localhost",
        7777
);

// retrieves the proxy to the MixinImpl instance
Mixin mixin = (Mixin)remoteProxy.getInstance();

// invoke methods on the proxy (executed on the server)
System.out.println("Mixin says: " + mixin.test1());

// close the proxy (close() must always be called)
remoteProxy.close();
...
                                ]]></source>
                            </p>
                        </li>
                        <br/>
                        <li>
                            create an instance of some class on the server-side, wrap it with a
                            <code>RemoteProxy</code> and send to the client over the wire.
                            The client then have access to this specific instance on the server.
                            <p>
                                <b>Server side:</b>
                                <source><![CDATA[
    ...
    // wrap an instance in a remote proxy on the server-side and send it to the client
    RemoteProxy remoteProxy = RemoteProxy.createServerProxy(anotherMixinInstance, "localhost", 7777);
    return remoteProxy;
}
                                ]]></source>
                            </p>
                            <p>
                                <b>Client side:</b>
                                <source><![CDATA[
...
// retrieve the proxy to the specific instance created on the server
RemoteProxy remoteProxy = mixin.getMixin();

// retrieves the proxy to the instance on the server
AnotherMixin anotherMixin = (AnotherMixin)remoteProxy.getInstance();
...
                                ]]></source>
                            </p>
                        </li>
                    </ul>
                </p>
                <p>
                    A sample have been provided and can be found in the
                    <code>src/samples/examples/connectiviy</code>
                    directory. Start by taking a look at the
                    <code>Client.java</code> class.
                    You can run the sample by executing
                    <code>maven aspectwerkz:samples:remote:server</code>
                    to start up the server and then in another console execute
                    <code>maven aspectwerkz:samples:remote:client</code> to start the client.
                    (When you close down the server using
                    <code>^C</code> then the server listener
                    threads are still hanging so you need to close down them manually.)
                </p>
            </subsection>
            <subsection name="Server side">
                <p>
                    The remote proxy server is a multi-threaded production-ready implementation that
                    is ready to serve any number of incoming requests. To configure the server settings
                    (number of listener threads, max/min/init size of the thread pool, backlog etc.)
                    you have to change the settings in the in the
                    <code>aspectwerkz.properties</code>
                    resource bundle and put it on the classpath. If no bundle is found default
                    values are used.
                </p>
                <p>
                    The server resource bundle has the following format/options:
                    <source><![CDATA[
remote.server.hostname=localhost
remote.server.port=7777
remote.server.client.threads.timeout=60000
remote.server.listener.threads.nr=10
remote.server.listener.threads.backlog=200
remote.server.listener.threads.run.as.daemon=false
remote.server.thread.pool.type=bounded # possible types are bounded or dynamic
remote.server.thread.pool.max.size=100
remote.server.thread.pool.init.size=10
remote.server.thread.pool.min.size=10
remote.server.thread.pool.keep.alive.time=300000
remote.server.thread.pool.wait.when.blocked=true
remote.server.invoker.classname=
                    ]]></source>
                </p>
                <p>
                    To enable support for RPC in the
                    <code>AspectWerkz</code> system you have to feed
                    the JVM with the
                    <code>-Daspectwerkz.remote.server.run=true</code> option.
                </p>
                <p>
                    If you have specific requirements. For example if you want to handle the user
                    context that you (optionally) can set on the client
                    <code>RemoteProxy</code>
                    and have sent over or have other requirements on how you want to invoke you
                    objects then you can create your own implementation of the
                    <code>org.codehaus.aspectwerkz.connectivity.Invoker</code> interface and
                    specify the implementation in the aspectwerkz.properties resource bundle using
                    the
                    <code>remote.server.invoker.classname=..</code> option. For an example
                    implementation see the
                    <code>org.codehaus.aspectwerkz.System.getDefaultInvoker()</code> method.
                </p>
            </subsection>
        </section>

        <!--        <section name="Examples">-->
        <!--            <subsection name="WebLogic Server and BEA JRockit integration">-->
        <!--                <p>-->
        <!--                    -Xmanagement-->
        <!--                    Console option-->
        <!--                    Link to-->
        <!--                </p>-->
        <!--            </subsection>-->
        <!--            <subsection name="WebLogic Server domain wizards">-->
        <!--                <p>-->
        <!--                    TODO + link to some stuff-->
        <!--                </p>-->
        <!--            </subsection>-->
        <!--            <subsection name="Tomcat">-->
        <!--                <p>-->
        <!--                    TODO-->
        <!--                </p>-->
        <!--            </subsection>-->
        <!--        </section>-->
    </body>
</document>
