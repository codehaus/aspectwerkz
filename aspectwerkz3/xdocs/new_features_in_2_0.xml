<?xml version="1.0"?>
<document>
    <properties>
        <author email="jboner at codehaus dot org">jonas bon&#233;r</author>
        <title>Notes on the new 2.x architecture</title>
    </properties>
    <body>
        <section name="Table of Contents">
            <p>
                <ol>
                    <li>
                        <a href="#New fast, open and dynamic weaving engine">New fast, open and dynamic weaving engine</a>
                    </li>
                    <li>
                        <a href="#Hot deployment and undeployment of aspects">Hot deployment and undeployment of aspects</a>
                    </li>
                    <li>
                        <a href="#Richer after advice semantics">Richer after advice semantics</a>
                    </li>
                    <li>
                        <a href="#StaticJoinPoint vs. JoinPoint">StaticJoinPoint vs. JoinPoint</a>
                    </li>
                </ol>
            </p>
        </section>
        <section name="New fast, open and dynamic weaving engine">
            <p>

            </p>
        </section>

        <section name="Hot deployment and undeployment of aspects">
            <p>
                <code>AspectWerkz</code> supports both hot deployment and hot undeployment of aspects.
                It utilizes HotSwap (Java 1.4) or JVMTI (Java 5) to redefine your application at runtime.
                New aspects can be added to the running system and old ones can be redefined or removed at runtime.
            </p>
            <p>
                All these services are accessed from the
                <code>org.codehaus.aspectwerkz.transform.inlining.deployer.Deployer</code> class, which as a rich
                set of services.
            </p>
            <subsection name="Deployment">
                <p>
                Deployment of aspects is done using one of the
                    <code>Deployer.deploy(..)</code> methods.
                </p>
                <p>
                    Here is the API for deployment of aspects (see details below):
                    <source><![CDATA[
DeploymentHandle deploy(Class aspect)

DeploymentHandle deploy(Class aspect, ClassLoader deployLoader)

DeploymentHandle deploy(Class aspect, DeploymentScope scope, ClassLoader deployLoader)

DeploymentHandle deploy(Class aspect, String xmlDef)

DeploymentHandle deploy(Class aspect, String xmlDef, ClassLoader deployLoader)

DeploymentHandle deploy(Class aspect, String xmlDef, DeploymentScope scope)

DeploymentHandle deploy(Class aspect, String xmlDef, DeploymentScope scope, ClassLoader deployLoader)
                    ]]></source>
                </p>
                <p>
                    <b>Details on the deployment API:</b>
                </p>
                <p>

                    <ul>
                        <li>
                    The first three methods are for deployment of annotation defined aspects only and
                    the last three for XML defined aspects (that can have annotations as well, if so then
                    the XML definition will override the annotation definition, but apart from that they
                    will merge).
                        </li>
                        <br/>
                        <li>
                    As you can see all methods returns a
                            <code>DeploymentHandle</code>, read more about
                    that in the section about deployment handles below.
                        </li>
                        <br/>
                        <li>
                    The class loader passed to the method is the class loader that you want the aspect to
                    be deployed in. If no class loader is specified then it will use the loader that loaded
                    the aspect class. (Note: the algorithm will
                            <b>not</b> handle importing classes from one
                    class loader to another so they need to be in the same hierarchy.)
                        </li>
                        <br/>
                        <li>
                    It is recommended that you pass a
                            <code>DeploymentScope</code> to the
                            <code>deploy</code>
                    method if you want predictable and safe deployment. For details, see the section on deployment
                    scopes below.
                        </li>
                    </ul>
                </p>

            </subsection>
            <subsection name="Undeployment">
                <p>
                Undeployment of aspects is done using one of the
                    <code>Deployer.undeploy(..)</code> methods.
                </p>
                <p>
                    Here is the API for undeployment of aspects (see details below):
                    <source><![CDATA[
void undeploy(Class aspect)

void undeploy(Class aspect, ClassLoader loader)

void undeploy(DeploymentHandle deploymentHandle)
                    ]]></source>
                </p>
                <p>
                    <b>Details on the deployment API:</b>
                </p>
                <p>
                    <ul>
                        <li>
                    You can undeploy an aspect by just specifying the aspect's class. This means that the
                    aspect will be undeployed from the class loader that has loaded the aspect class.
                        </li>
                        <br/>
                        <li>
                    If you specify a class loader then the aspect will be undeployed from the class loader that
                    is specified.
                        </li>
                        <br/>
                        <li>
                    If you specify a
                            <code>DeploymentHandle</code> then all join points that where affected by
                    the deployment event is defined by the handle will be reverted to the state they where in
                    before the deployment occured. This means that
                            <b>you</b> need to keep track of order and
                    dependencies etc. e.g. f.e. rollback all changes in the correct order etc.
                        </li>
                        <br/>
                        <li>
                    If an aspect that is being undeployed can not be found (e.g. is not deployed or is already
                    undeployed) then nothing happens. No error is triggered.
                        </li>
                    </ul>
                </p>

            </subsection>
            <subsection name="Deployment scopes">
                <p>
                The use of deployment scopes give you more predictable and safer deployment.
                </p>
                <p>
                They are needed due to the fact that no JVMs today support schema redefinition when
                redefining your classes.
                </p>
                <p>
                This means that you have to define a special kind of pointcut that we call deployment scope,
                which will prepare you application and advise the points that you are interested in doing
                hot depoyment on later.
                </p>
                <p>
                You can then retrieve a handle to this deployment scope by getting
                the actual instance of the abstraction and then use this to narrow down the scope of
                the deployment so you are sure that you will not try to deploy the aspect at points in your
                code that will not be affected. Hence you are garantueed that your aspect will be deployed at
                valid points in your code.
                </p>
                <p>
                    <b>Definition</b>
                </p>
                <p>
                    You define the deployment scope just as regular pointcuts, in its own aspect or in the same
                    aspect as the rest of your code:
                    <source><![CDATA[
/**
 * @Expression execution(String *.toString())
 */
DeploymentScope toString;
                    ]]></source>

                    <source><![CDATA[
<deployment-scope name="toString" expression="execution(String *.toString())"/>
                    ]]></source>
                </p>
                <p>
                    <b>Runtime retrieval</b>
                </p>
                <p>
                    You can then retrieve the instance of the
                    <code>DeploymentScope</code> like this:
                    <source><![CDATA[
DeploymentScope deploymentScope = SystemDefinition.getDefinitionFor(loader, systemId).getDeploymentScope("toString");
                    ]]></source>
                </p>
            </subsection>
            <subsection name="Deployment handles">
            </subsection>
        </section>
        <section name="Richer after advice semantics">
            <p>
            </p>
            <subsection name="After finally">
            </subsection>
            <subsection name="After returning [TYPE]">
            </subsection>
            <subsection name="After throwing [TYPE];">
            </subsection>
        </section>
        <section name="StaticJoinPoint vs. JoinPoint">
            <p>
            </p>
        </section>
    </body>
</document>

