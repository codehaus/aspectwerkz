/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. grammar.jj */
/*@egen*/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       

PARSER_BEGIN(ExpressionParser)
/**************************************************************************************
 * Copyright (c) Jonas Bon\u00e9r, Alexandre Vasseur. All rights reserved.                 *
 * http://aspectwerkz.codehaus.org                                                    *
 * ---------------------------------------------------------------------------------- *
 * The software in this package is published under the terms of the LGPL license      *
 * a copy of which has been included with this distribution in the license.txt file.  *
 **************************************************************************************/
package org.codehaus.aspectwerkz.expression.ast;

import java.lang.reflect.Modifier;
import java.io.Reader;
import java.io.StringReader;

/**
 * Usage:
 *  <pre>
 *     ExpressionParser parser = new ExpressionParser(System.in); // can be only one
 *     ASTRoot root = parser.parse("call(@RequiresNew public * foo.Bar.*(String, ..) AND withincode(* foo.Baz.within(..)");
 *     Expression expression = new Expression(root);
 *     ...
 *  </pre>
 *
 * @author <a href="mailto:jboner@codehaus.org">Jonas Bon\u00e9r</a>
 */
public class ExpressionParser/*@bgen(jjtree)*/implements ExpressionParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTExpressionParserState jjtree = new JJTExpressionParserState();

/*@egen*/

    public ASTRoot parse(String expression) throws ParseException {
        return parse(new StringReader(expression));
    }

    public ASTRoot parse(Reader reader) throws ParseException {
        ReInit(reader);
        return Root();
    }
}
PARSER_END(ExpressionParser)

//------------------ Global lexical scope ------------------

SKIP : /* WHITE SPACE */
{
    " "
|
    "\t"
}
TOKEN : /* LOGICAL OPERATORS */
{
    < AND : "&&" | "and" | "AND" | "&" >
|
    < OR  : "||" | "or"  | "OR"  | "|" >
|
    < NOT : "!"  | "not" | "NOT" >
}
TOKEN : /* POINTCUTS */
{
    < POINTCUT_REFERENCE : (["a"-"z", "A"-"Z", "_", "$", ".", "0"-"9"])+ >
|
    < EXECUTION : "execution(" > : METHOD
|
    < CALL : "call(" > : METHOD
|
    < SET : "set(" > : FIELD
|
    < GET : "get(" > : FIELD
|
    < HANDLER : "handler(" > : CLASS
|
    < WITHIN : "within(" > : CLASS
|
    < WITHIN_CODE : "withincode(" > : METHOD
|
    < STATIC_INITIALIZATION : "staticinitialization(" > : CLASS
|
    < CFLOW : "cflow(" >
|
    < CFLOW_BELOW : "cflowbelow(" >
|
    < ARGS : "args(" >
|
    < TARGET : "target(" > : CLASS
|
    < THIS : "this(" > : CLASS
|
    < IF : "if(" >
|
    < #DOT: "." >
|
    < #WILDCARD: "*" >
|
    < #ARRAY: "[]" >
|
    < EAGER_WILDCARD: <DOT> <DOT> >
}

//------------------ Lexical scope for classes ------------------

<CLASS> SKIP : /* WHITE SPACE */
{
    " "
|
    "\t"
}
<CLASS> TOKEN :
{
    < CLASS_PRIVATE: "private" >
|
    < CLASS_PROTECTED: "protected" >
|
    < CLASS_PUBLIC: "public" >
|
    < CLASS_STATIC: "static" >
|
    < CLASS_ABSTRACT: "abstract" >
|
    < CLASS_FINAL: "final" >
|
    < CLASS_ATTRIBUTE : "@" <CLASS_IDENTIFIER> >
|
    < CLASS_PATTERN: <CLASS_IDENTIFIER> (<DOT> <CLASS_IDENTIFIER>)* >
|
    < #CLASS_IDENTIFIER: (<CLASS_JAVA_NAME_LETTER> | <EAGER_WILDCARD> | <WILDCARD>)+ >
|
    < #CLASS_JAVA_NAME_LETTER: ["a"-"z", "A"-"Z", "_", "$", "+", "#", "0"-"9"] >
|
    < CLASS_POINTCUT_END: ")" > : DEFAULT
}

//------------------ Lexical scope for methods ------------------

<METHOD> SKIP : /* WHITE SPACE */
{
    " "
|
    "\t"
}
<METHOD> TOKEN :
{
    < METHOD_PUBLIC: "public" >
|
    < METHOD_PROTECTED: "protected" >
|
    < METHOD_PRIVATE: "private" >
|
    < METHOD_STATIC: "static" >
|
    < METHOD_ABSTRACT: "abstract" >
|
    < METHOD_FINAL: "final" >
|
    < METHOD_NATIVE: "native" >
|
    < METHOD_SYNCHRONIZED: "synchronized" >
|
    < METHOD_ATTRIBUTE : "@" <METHOD_IDENTIFIER> >
|
    < #METHOD_IDENTIFIER: (<METHOD_JAVA_NAME_LETTER> | <EAGER_WILDCARD> | <WILDCARD>)+ >
|
    < METHOD_CLASS_PATTERN: <METHOD_IDENTIFIER> (<DOT> <METHOD_IDENTIFIER>)* >
|
    < METHOD_ARRAY_CLASS_PATTERN: <METHOD_CLASS_PATTERN> (<ARRAY>)+ >
|
    < COMMA: "," >
|
    < PARAMETER_START: "(" >
|
    < PARAMETER_END: ")" > : DEFAULT
|
    < #METHOD_JAVA_NAME_LETTER: ["a"-"z", "A"-"Z", "_", "$", "+", "#", "0"-"9"] >
}

//------------------ Lexical scope for fields ------------------

<FIELD> SKIP : /* WHITE SPACE */
{
    " "
|
    "\t"
}
<FIELD> TOKEN :
{
    < FIELD_PRIVATE: "private" >
|
    < FIELD_PROTECTED: "protected" >
|
    < FIELD_PUBLIC: "public" >
|
    < FIELD_STATIC: "static" >
|
    < FIELD_ABSTRACT: "abstract" >
|
    < FIELD_FINAL: "final" >
|
    < FIELD_TRANSIENT: "transient" >
|
    < FIELD_ATTRIBUTE : "@" <FIELD_IDENTIFIER> >
|
    < #FIELD_IDENTIFIER: (<FIELD_JAVA_NAME_LETTER> | <EAGER_WILDCARD> | <WILDCARD>)+ >
|
    < FIELD_CLASS_PATTERN: <FIELD_IDENTIFIER> (<DOT> <FIELD_IDENTIFIER>)* >
|
    < FIELD_ARRAY_CLASS_PATTERN: <FIELD_CLASS_PATTERN> (<ARRAY>)+ >
|
    < #FIELD_JAVA_NAME_LETTER: ["a"-"z", "A"-"Z", "_", "$", "+", "#", "0"-"9"] >
|
    < FIELD_POINTCUT_END: ")" > : DEFAULT
}

//------------------ Lexical scope for parameters ------------------

<PARAMETERS> SKIP : /* WHITE SPACE */
{
    " "
|
    "\t"
}
<PARAMETERS> TOKEN :
{
    < #PARAMETER_IDENTIFIER: (<PARAMETER_JAVA_NAME_LETTER> | <EAGER_WILDCARD> | <WILDCARD>)+ >
|
    < PARAMETER_CLASS_PATTERN: <PARAMETER_IDENTIFIER> (<DOT> <PARAMETER_IDENTIFIER>)* >
|
    < PARAMETER_ARRAY_CLASS_PATTERN: <PARAMETER_CLASS_PATTERN> (<ARRAY>)+ >
|
    < PARAMETER_ANNOTATION: "@" <PARAMETER_IDENTIFIER> >
|
    < #PARAMETER_JAVA_NAME_LETTER: ["a"-"z", "A"-"Z", "_", "$", "+", "#", "0"-"9"] >
}

//------------------ Bootstrap ------------------

/**
 * Entry point.
 */
ASTRoot Root()       : {/*@bgen(jjtree) Root */
  ASTRoot jjtn000 = new ASTRoot(JJTROOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Root */
    try {
/*@egen*/
    Expression() <EOF>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Expression.
 */
void Expression() : {}
{
    AndExpression()
}

//------------------ Logical operators ------------------

/**
 * AndExpression.
 */
void AndExpression() : {}
{/*@bgen(jjtree) #And(> 1) */
    {
      ASTAnd jjtn001 = new ASTAnd(JJTAND);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (OrExpression() (LOOKAHEAD(2) <AND> OrExpression())*)/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
      }
    }
/*@egen*/
}

/**
 * OrExpression.
 */
void OrExpression() : {}
{/*@bgen(jjtree) #Or(> 1) */
    {
      ASTOr jjtn001 = new ASTOr(JJTOR);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (UnaryExpression() (LOOKAHEAD(2) <OR> AndExpression())*)/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
      }
    }
/*@egen*/
}

/**
 * UnaryExpression.
 */
void UnaryExpression() : {}
{
    NotExpression() | "(" Expression() ")" | Pointcut()
}


/**
 * NotExpression.
 */
void NotExpression() : {}
{
    <NOT>/*@bgen(jjtree) #Not(true) */
          {
            ASTNot jjtn001 = new ASTNot(JJTNOT);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
          }
          try {
/*@egen*/ UnaryExpression()/*@bgen(jjtree)*/
          } catch (Throwable jjte001) {
            if (jjtc001) {
              jjtree.clearNodeScope(jjtn001);
              jjtc001 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte001 instanceof RuntimeException) {
              throw (RuntimeException)jjte001;
            }
            if (jjte001 instanceof ParseException) {
              throw (ParseException)jjte001;
            }
            throw (Error)jjte001;
          } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001, true);
            }
          }
/*@egen*/
}

//------------------ Pointcuts ------------------

/**
 * Pointcut.
 */
void Pointcut() : {}
{
    LOOKAHEAD(4) PointcutReference() |
    LOOKAHEAD(4) Call() |
    LOOKAHEAD(4) Execution() |
    LOOKAHEAD(4) Set() |
    LOOKAHEAD(4) Get() |
    LOOKAHEAD(4) Handler() |
    LOOKAHEAD(4) Within() |
    LOOKAHEAD(4) WithinCode() |
    LOOKAHEAD(4) StaticInitialization() |
    LOOKAHEAD(4) Cflow() |
    LOOKAHEAD(4) CflowBelow()
}

/**
 * Pointcut reference.
 */
void PointcutReference()                    :
{/*@bgen(jjtree) PointcutReference */
    ASTPointcutReference jjtn000 = new ASTPointcutReference(JJTPOINTCUTREFERENCE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token name;
}
{/*@bgen(jjtree) PointcutReference */
    try {
/*@egen*/
    name=<POINTCUT_REFERENCE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setName(name.image);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Execution.
 */
void Execution()            : {/*@bgen(jjtree) Execution */
  ASTExecution jjtn000 = new ASTExecution(JJTEXECUTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Execution */
    try {
/*@egen*/
    <EXECUTION> (LOOKAHEAD(2) MethodPattern() | ConstructorPattern()) ")"/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Call.
 */
void Call()       : {/*@bgen(jjtree) Call */
  ASTCall jjtn000 = new ASTCall(JJTCALL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Call */
    try {
/*@egen*/
    <CALL> (LOOKAHEAD(2) MethodPattern() | ConstructorPattern()) ")"/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Set.
 */
void Set()      : {/*@bgen(jjtree) Set */
  ASTSet jjtn000 = new ASTSet(JJTSET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Set */
    try {
/*@egen*/
    <SET> FieldPattern() <FIELD_POINTCUT_END>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Get.
 */
void Get()      : {/*@bgen(jjtree) Get */
  ASTGet jjtn000 = new ASTGet(JJTGET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Get */
    try {
/*@egen*/
    <GET> FieldPattern() <FIELD_POINTCUT_END>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Handler.
 */
void Handler()          : {/*@bgen(jjtree) Handler */
  ASTHandler jjtn000 = new ASTHandler(JJTHANDLER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Handler */
    try {
/*@egen*/
    <HANDLER> ClassPattern() <CLASS_POINTCUT_END>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Within.
 */
void Within()         : {/*@bgen(jjtree) Within */
  ASTWithin jjtn000 = new ASTWithin(JJTWITHIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Within */
    try {
/*@egen*/
    <WITHIN> ClassPattern() <CLASS_POINTCUT_END>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * WithinCode.
 */
void WithinCode()             : {/*@bgen(jjtree) WithinCode */
  ASTWithinCode jjtn000 = new ASTWithinCode(JJTWITHINCODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WithinCode */
   try {
/*@egen*/
   <WITHIN_CODE> MethodPattern() ")"/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

/**
 * StaticInitialization.
 */
void StaticInitialization()                       : {/*@bgen(jjtree) StaticInitialization */
  ASTStaticInitialization jjtn000 = new ASTStaticInitialization(JJTSTATICINITIALIZATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StaticInitialization */
    try {
/*@egen*/
    <STATIC_INITIALIZATION> ClassPattern() <CLASS_POINTCUT_END>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Cflow.
 */
void Cflow()        : {/*@bgen(jjtree) Cflow */
  ASTCflow jjtn000 = new ASTCflow(JJTCFLOW);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Cflow */
   try {
/*@egen*/
   <CFLOW> Expression() ")"/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

/**
 * CflowBelow.
 */
void CflowBelow()             : {/*@bgen(jjtree) CflowBelow */
  ASTCflowBelow jjtn000 = new ASTCflowBelow(JJTCFLOWBELOW);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CflowBelow */
   try {
/*@egen*/
   <CFLOW_BELOW> Expression() ")"/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

//------------------ Patterns ------------------

/**
 * Class pattern.
 */
void ClassPattern()               :
{/*@bgen(jjtree) ClassPattern */
    ASTClassPattern jjtn000 = new ASTClassPattern(JJTCLASSPATTERN);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token pattern;
}
{/*@bgen(jjtree) ClassPattern */
    try {
/*@egen*/
    (ClassAttribute())*
    (ClassModifier())*
    pattern=<CLASS_PATTERN>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setTypePattern(pattern.image);
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
//    (<CLASS_HIERARCHICAL>
//    {
//        jjtThis.setHierarchical(true);
//    }
//    )*
}

/**
 * Method pattern.
 *
 * @TODO: split class name and method name.
 * @TODO: handle '+'.
 * @TODO: put method name, return type and declaring class in different nodes.
 */
void MethodPattern()                :
{/*@bgen(jjtree) MethodPattern */
    ASTMethodPattern jjtn000 = new ASTMethodPattern(JJTMETHODPATTERN);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token returnType, name;
}
{/*@bgen(jjtree) MethodPattern */
    try {
/*@egen*/
    (MethodAttribute())*
    (MethodModifier())*
    (returnType=<METHOD_CLASS_PATTERN> | returnType=<METHOD_ARRAY_CLASS_PATTERN>)
    {
        jjtn000.setReturnTypePattern(returnType.image);
    }
    name=<METHOD_CLASS_PATTERN>
    {
        jjtn000.setFullNamePattern(name.image);
    }
    Parameters()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Constructor pattern.
 *
 * @TODO: split class name and constructor name ('new').
 * @TODO: handle '+'.
 * @TODO: put declaring class in a different node.
 */
void ConstructorPattern()                     :
{/*@bgen(jjtree) ConstructorPattern */
    ASTConstructorPattern jjtn000 = new ASTConstructorPattern(JJTCONSTRUCTORPATTERN);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token name;
}
{/*@bgen(jjtree) ConstructorPattern */
    try {
/*@egen*/
    (MethodAttribute())*
    (ConstructorModifier())*
    name=<METHOD_CLASS_PATTERN>
    {
        if (!name.image.endsWith("new")) {
            throw new RuntimeException("constructor pattern must have 'new' as method name");
        }
        jjtn000.setFullNamePattern(name.image);
    }
    Parameters()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Field pattern.
 *
 * @TODO: split class name and field name.
 * @TODO: handle '+'.
 * @TODO: put field name, field type and declaring class in different nodes.
 */
void FieldPattern()               :
{/*@bgen(jjtree) FieldPattern */
    ASTFieldPattern jjtn000 = new ASTFieldPattern(JJTFIELDPATTERN);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token type, name;
}
{/*@bgen(jjtree) FieldPattern */
    try {
/*@egen*/
    (FieldAttribute())*
    (FieldModifier())*
    (type=<FIELD_CLASS_PATTERN> | type=<FIELD_ARRAY_CLASS_PATTERN>)
    {
        jjtn000.setFieldTypePattern(type.image);
    }
    name=<FIELD_CLASS_PATTERN>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setFullNamePattern(name.image);
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Parameters.
 */
void Parameters() : {}
{
    <PARAMETER_START> (<EAGER_WILDCARD> | [Parameter() (<COMMA> Parameter())* ]) <PARAMETER_END>
}

/**
 * Parameter pattern.
 */
void Parameter()            :
{/*@bgen(jjtree) Parameter */
    ASTParameter jjtn000 = new ASTParameter(JJTPARAMETER);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token parameter;
}
{/*@bgen(jjtree) Parameter */
    try {
/*@egen*/
    (parameter=<METHOD_CLASS_PATTERN> | parameter=<METHOD_ARRAY_CLASS_PATTERN>)/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setTypePattern(parameter.image);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Class attribute.
 */
void ClassAttribute()            :
{/*@bgen(jjtree) Attribute */
    ASTAttribute jjtn000 = new ASTAttribute(JJTATTRIBUTE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token attribute;
}
{/*@bgen(jjtree) Attribute */
    try {
/*@egen*/
    attribute=<CLASS_ATTRIBUTE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setName(attribute.image);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Method attribute.
 */
void MethodAttribute()            :
{/*@bgen(jjtree) Attribute */
    ASTAttribute jjtn000 = new ASTAttribute(JJTATTRIBUTE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token attribute;
}
{/*@bgen(jjtree) Attribute */
    try {
/*@egen*/
    attribute=<METHOD_ATTRIBUTE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setName(attribute.image);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Field attribute.
 */
void FieldAttribute()            :
{/*@bgen(jjtree) Attribute */
    ASTAttribute jjtn000 = new ASTAttribute(JJTATTRIBUTE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token attribute;
}
{/*@bgen(jjtree) Attribute */
    try {
/*@egen*/
    attribute=<FIELD_ATTRIBUTE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setName(attribute.image);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Class modifier.
 */
void ClassModifier()           : {/*@bgen(jjtree) Modifier */
  ASTModifier jjtn000 = new ASTModifier(JJTMODIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Modifier */
   try {
/*@egen*/
   <CLASS_PUBLIC>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.PUBLIC);
    }
    |
    <CLASS_PROTECTED>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.PROTECTED);
    }
    |
    <CLASS_PRIVATE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.PRIVATE);
    }
    |
    <CLASS_STATIC>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.STATIC);
    }
    |
    <CLASS_ABSTRACT>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.ABSTRACT);
    }
    |
    <CLASS_FINAL>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.FINAL);
    }/*@bgen(jjtree)*/
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

/**
 * Method modifier.
 */
void MethodModifier()           : {/*@bgen(jjtree) Modifier */
  ASTModifier jjtn000 = new ASTModifier(JJTMODIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Modifier */
    try {
/*@egen*/
    <METHOD_PUBLIC>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.PUBLIC);
    }
    |
    <METHOD_PROTECTED>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.PROTECTED);
    }
    |
    <METHOD_PRIVATE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.PRIVATE);
    }
    |
    <METHOD_STATIC>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.STATIC);
    }
    |
    <METHOD_ABSTRACT>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.ABSTRACT);
    }
    |
    <METHOD_FINAL>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.FINAL);
    }
    |
    <METHOD_NATIVE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.NATIVE);
    }
    |
    <METHOD_SYNCHRONIZED>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.SYNCHRONIZED);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Constructor modifier.
 */
void ConstructorModifier()           : {/*@bgen(jjtree) Modifier */
  ASTModifier jjtn000 = new ASTModifier(JJTMODIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Modifier */
    try {
/*@egen*/
    <METHOD_PUBLIC>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.PUBLIC);
    }
    |
    <METHOD_PROTECTED>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.PROTECTED);
    }
    |
    <METHOD_PRIVATE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.PRIVATE);
    }
    |
    <METHOD_SYNCHRONIZED>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.SYNCHRONIZED);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Field modifier.
 */
void FieldModifier()           : {/*@bgen(jjtree) Modifier */
  ASTModifier jjtn000 = new ASTModifier(JJTMODIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Modifier */
   try {
/*@egen*/
   <FIELD_PUBLIC>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.PUBLIC);
    }
    |
    <FIELD_PROTECTED>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.PROTECTED);
    }
    |
    <FIELD_PRIVATE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.PRIVATE);
    }
    |
    <FIELD_STATIC>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.STATIC);
    }
    |
    <FIELD_ABSTRACT>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.ABSTRACT);
    }
    |
    <FIELD_FINAL>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.FINAL);
    }
    |
    <FIELD_TRANSIENT>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.TRANSIENT);
    }/*@bgen(jjtree)*/
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

